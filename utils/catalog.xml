<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='../resources/catalog.xsl'?>
<c:catalog xmlns="http://zero-install.sourceforge.net/2004/injector/interface" xmlns:c="http://0install.de/schema/injector/catalog"><interface uri="https://apps.0install.net/utils/advancecomp.xml"><name>AdvanceCOMP</name><summary xml:lang="en">AdvanceCOMP is a collection of recompression utilities for your .ZIP archives, .PNG snapshots, .MNG video clips and .GZ files. </summary><description xml:lang="en">It's mainly intended for recompressing your rom, snapshot and clip collection of emulated games. 

The main features are : 
•Recompress ZIP, GZ, PNG and MNG files using the Deflate 7-Zip implementation. 
•Recompress MNG files using Delta and Move optimization. 
</description><category>Graphics</category><homepage>http://www.advancemame.it/comp-readme</homepage><entry-point binary-name="advdef" command="run">
    <needs-terminal/>
    <name xml:lang="en">advdef</name>
    <summary xml:lang="en">AdvanceCOMP Deflate Compression Utility</summary>
    <description xml:lang="en">The main purpose of this utility is to recompress the
data present in the .png, .mng, .gz, .tgz and .svgz
files.

The internal structure of the files isn't changed.
Only the compressed data is modified.</description>
  </entry-point><entry-point binary-name="advmng" command="advmng">
    <needs-terminal/>
    <name xml:lang="en">advmng</name>
    <summary xml:lang="en">AdvanceCOMP MNG Compression Utility</summary>
    <description xml:lang="en">The main purpose of this utility is to recompress MNG
files to get the smallest possible size.

Please note that this utility is not able to read
a generic file. It's granted to be able to read only
the files generated by the AdvanceMAME emulator.

To compress the files this utility uses the following
strategies:

* Remove all ancillary chunks.
* Use the MNG Delta feature to compress video clips with
  only small changes between frames.
* Use the MNG Move feature to compress video clips with
  a scrolling background (option -s).
* Reduce the color depth to 8 bit (option -r).
* Use the 7zip Deflate implementation.</description>
  </entry-point><entry-point binary-name="advpng" command="advpng">
    <needs-terminal/>
    <name xml:lang="en">advpng</name>
    <summary xml:lang="en">AdvanceCOMP PNG Compression Utility</summary>
    <description xml:lang="en">The main purpose of this utility is to recompress png
files to get the smallest possible size.

Please note that this utility is not able to read
a generic file. It's granted to be able to read only
the files generated by the AdvanceMAME emulator.

To compress the files this utility uses the following
strategies:

* Remove all ancillary chunks.
* Concatenate all the IDAT chunks.
* Use the 7zip Deflate implementation.</description>
  </entry-point><entry-point binary-name="advzip" command="advzip">
    <needs-terminal/>
    <name xml:lang="en">advzip</name>
    <summary xml:lang="en">AdvanceCOMP ZIP Compression Utility</summary>
    <description xml:lang="en">The main purpose of this utility is to recompress and test
the zip archives to get the smallest possible size.

For recompression the libdeflate implementation is used.
This implementation generally gives 5-10% more compression
than the zLib Deflate implementation, and it's also
generally faster.

For experimental purpose also the 7-Zip LZMA algorithm is
available with the -N option. In this case, the generated
zips WILL NOT BE USABLE by any other program. To make
them usable you need to recompress them without the -N
option. Generally this algorithm gives 10-20% more
compression than the zLib Deflate implementation.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/arc.xml"><name>Arc</name><summary xml:lang="en">Arc: create and extract files from DOS .ARC files</summary><description xml:lang="en">This package creates and extracts-from ARC archives. An ARC archive contains files which are compressed according to the most efficient of three algorithms. ARC archives are usually only used for compatibility with MS-DOS. 
This port of Arc can be used as a plugin for WinZip. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/arc.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/arc.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/arc.htm</homepage><entry-point binary-name="arc" command="run">
    <needs-terminal/>
    <summary xml:lang="en">pc archive utility</summary>
    <description xml:lang="en">Arc is a general archive and file compression utility, used to maintain a compressed archive of files.
An archive is a single file that combines many files, reducing storage space and allowing multiple files to be handled as one.
Arc uses one of several compression methods for each file within the archive, based on whichever method yields the smallest result.</description>
  </entry-point><entry-point binary-name="marc" command="marc">
    <needs-terminal/>
    <summary xml:lang="en">Archive merger</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/arj.xml"><name>Arj</name><summary xml:lang="en">Arj: archiver for .arj files</summary><description xml:lang="en">ARJ is a file archiver that compresses files into a disk space saving archive. It is fast, reliable, and has a rich set of features which include Windows 9x, Millenium long filename support, file version management, data damage protection, ANSI escape sequence display handler, configurable command options, multiple volume archives (archives that span diskettes) and much more. </description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/arj.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/arj.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/arj.htm</homepage><entry-point binary-name="arj" command="run">
    <needs-terminal/>
    <summary xml:lang="en">Archiver for .arj files</summary>
    <description xml:lang="en">arj  command  [-switch[-|+|option]]  archive[.arj] [base
       directory] [!list name|path name|wildcard name]</description>
  </entry-point><entry-point binary-name="arj-register" command="arj-register">
    <needs-terminal/>
    <name xml:lang="en">arj-register</name>
    <summary xml:lang="en">Register the ARJ archiver</summary>
    <description xml:lang="en">arj-register [options] program_name</description>
  </entry-point><entry-point binary-name="arjdisp" command="arjdisp">
    <needs-terminal/>
    <name xml:lang="en">arjdisp</name>
    <summary xml:lang="en">ARJ simple graphical interface</summary>
    <description xml:lang="en">The arjdisp command is a graphical interface for arj.</description>
  </entry-point><entry-point binary-name="rearj" command="rearj">
    <needs-terminal/>
    <name xml:lang="en">rearj</name>
    <summary xml:lang="en">Converts other archive formats to .arj files</summary>
    <description xml:lang="en">The rearj command can repackage other archive formats to arj.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/bzip2.xml"><name>Bzip2</name><summary xml:lang="en">A program and library for data compression</summary><description xml:lang="en">bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression. The code is organised as a library, with a programming interface. The bzip2 program itself is a client of the library. You can use the library in your own programs, to directly read and write .bz2 files, or even just to compress data in memory using the bzip2 algorithms.</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/bzip2.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/bzip2.png" type="image/png"/><category>Utility</category><homepage>https://sourceforge.net/projects/ezwinports/</homepage><entry-point binary-name="bzip2" command="run">
    <needs-terminal/>
    <summary xml:lang="en">a block-sorting file compressor, v1.0.4</summary>
    <description xml:lang="en">bzip2 compresses files using the  Burrows-Wheeler  block
       sorting  text compression algorithm, and Huffman coding.
       Compression is generally considerably better  than  that
       achieved  by  more conventional LZ77/LZ78-based compres-
       sors, and approaches the performance of the  PPM  family
       of statistical compressors.</description>
  </entry-point><entry-point binary-name="bunzip2" command="bunzip2">
    <needs-terminal/>
    <summary xml:lang="en">a block-sorting file compressor, v1.0.4</summary>
    <description xml:lang="en">bunzip2 decompresses all specified files.
       Files which were not created by bzip2 will  be  detected
       and  ignored,  and  a warning issued. </description>
  </entry-point><entry-point binary-name="bzcat" command="bzcat">
    <needs-terminal/>
    <summary xml:lang="en">decompresses files to stdout</summary>
    <description xml:lang="en">bzcat (or bzip2 -dc) decompresses all specified files to
       the standard output.</description>
  </entry-point><entry-point binary-name="bzip2recover" command="bzip2recover">
    <needs-terminal/>
    <summary xml:lang="en">recovers data from damaged bzip2 files</summary>
  </entry-point><entry-point binary-name="bzcmp" command="bzcmp">
    <needs-terminal/>
    <summary xml:lang="en">compare bzip2 compressed files</summary>
    <description xml:lang="en">Used to invoke the cmp or the diff
       program on bzip2 compressed files.  All  options  speci-
       fied are passed directly to cmp or diff.  If only 1 file
       is specified, then the files compared are file1  and  an
       uncompressed  file1.bz2.   If  two  files are specified,
       then they are uncompressed if necessary and fed  to  cmp
       or diff.  The exit status from cmp or diff is preserved.</description>
  </entry-point><entry-point binary-name="bzdiff" command="bzdiff">
    <needs-terminal/>
    <summary xml:lang="en">compare bzip2 compressed files</summary>
    <description xml:lang="en">used to invoke the cmp or the diff
       program on bzip2 compressed files.  All  options  speci-
       fied are passed directly to cmp or diff.  If only 1 file
       is specified, then the files compared are file1  and  an
       uncompressed  file1.bz2.   If  two  files are specified,
       then they are uncompressed if necessary and fed  to  cmp
       or diff.  The exit status from cmp or diff is preserved.</description>
  </entry-point><entry-point binary-name="bzegrep" command="bzegrep">
    <needs-terminal/>
    <summary xml:lang="en">search possibly bzip2 com-
       pressed files for a regular expression</summary>
    <description xml:lang="en">Bzgrep is used to invoke the  grep  on  bzip2-compressed
       files.  All  options  specified  are  passed directly to
       grep.  If no file is specified, then the standard  input
       is decompressed if necessary and fed to grep.  Otherwise
       the given files are uncompressed if necessary and fed to
       grep.

       If bzgrep is invoked as bzegrep or bzfgrep then egrep or
       fgrep is used instead of grep.  If the GREP  environment
       variable  is  set, bzgrep uses it as the grep program to
       be invoked. For example:

           for sh:  GREP=fgrep  bzgrep string files</description>
  </entry-point><entry-point binary-name="bzfgrep" command="bzfgrep">
    <needs-terminal/>
    <summary xml:lang="en">search possibly bzip2 com-
       pressed files for a regular expression</summary>
    <description xml:lang="en">Bzgrep is used to invoke the  grep  on  bzip2-compressed
       files.  All  options  specified  are  passed directly to
       grep.  If no file is specified, then the standard  input
       is decompressed if necessary and fed to grep.  Otherwise
       the given files are uncompressed if necessary and fed to
       grep.

       If bzgrep is invoked as bzegrep or bzfgrep then egrep or
       fgrep is used instead of grep.  If the GREP  environment
       variable  is  set, bzgrep uses it as the grep program to
       be invoked. For example:

           for sh:  GREP=fgrep  bzgrep string files</description>
  </entry-point><entry-point binary-name="bzgrep" command="bzgrep">
    <needs-terminal/>
    <summary xml:lang="en">search possibly bzip2 com-
       pressed files for a regular expression</summary>
    <description xml:lang="en">Bzgrep is used to invoke the  grep  on  bzip2-compressed
       files.  All  options  specified  are  passed directly to
       grep.  If no file is specified, then the standard  input
       is decompressed if necessary and fed to grep.  Otherwise
       the given files are uncompressed if necessary and fed to
       grep.

       If bzgrep is invoked as bzegrep or bzfgrep then egrep or
       fgrep is used instead of grep.  If the GREP  environment
       variable  is  set, bzgrep uses it as the grep program to
       be invoked. For example:

           for sh:  GREP=fgrep  bzgrep string files</description>
  </entry-point><entry-point binary-name="bzless" command="bzless">
    <needs-terminal/>
    <summary xml:lang="en">file perusal filter for crt viewing of
       bzip2 compressed text</summary>
    <description xml:lang="en">Bzless  is  a  filter  which  allows examination of com-
       pressed or plain text files one screenful at a time on a
       soft-copy  terminal.   bzless  works on files compressed
       with bzip2 and also on uncompressed files.   If  a  file
       does not exist, bzless looks for a file of the same name
       with the addition of a .bz2 suffix.

       Bzless normally pauses after  each  screenful,  printing
       --More--  at the bottom of the screen.  If the user then
       types a carriage return, one more line is displayed.  If
       the  user  hits a space, another screenful is displayed.
       Other possibilities are enumerated later.</description>
  </entry-point><entry-point binary-name="bzmore" command="bzmore">
    <needs-terminal/>
    <summary xml:lang="en">file perusal filter for crt viewing of
       bzip2 compressed text</summary>
    <description xml:lang="en">Bzmore  is  a  filter  which  allows examination of com-
       pressed or plain text files one screenful at a time on a
       soft-copy  terminal.   bzmore  works on files compressed
       with bzip2 and also on uncompressed files.   If  a  file
       does not exist, bzmore looks for a file of the same name
       with the addition of a .bz2 suffix.

       Bzmore normally pauses after  each  screenful,  printing
       --More--  at the bottom of the screen.  If the user then
       types a carriage return, one more line is displayed.  If
       the  user  hits a space, another screenful is displayed.
       Other possibilities are enumerated later.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/calc.xml"><name>Calc</name><summary xml:lang="en">Calc: arbitrary precision calculator</summary><description xml:lang="en">Calc is an interactive calculator which provides for easy large numeric calculations, but which also can be easily programmed for difficult or long calculations. It can accept a command line argument, in which case it executes that single command and exits. Otherwise, it enters interactive mode. There are a great number of pre-defined functions. The calculator can calculate transcendental functions, and accept and display numbers in real or exponential format. The calculator also knows about complex numbers. </description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/calc.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/calc.png" type="image/png"/><category>Office</category><homepage>http://gnuwin32.sourceforge.net/packages/calc.htm</homepage><entry-point binary-name="calc" command="run">
    <needs-terminal/>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/coreutils.xml"><name>CoreUtils</name><summary xml:lang="en">collection of basic file, shell and text manipulation utilities</summary><description xml:lang="en">The GNU Core Utilities are the basic file, shell and text manipulation utilities of the GNU operating system. These are the core utilities which are expected to exist on every operating system. </description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/coreutils.htm</homepage><entry-point binary-name="install" command="run">
    <summary xml:lang="en">copy files and set attributes</summary>
    <description xml:lang="en">In  the first three forms, copy SOURCE to DEST or multi-
       ple SOURCE(s) to the existing DIRECTORY,  while  setting
       permission modes and owner/group.  In the 4th form, cre-
       ate all components of the given DIRECTORY(ies).</description>
  </entry-point><entry-point binary-name="basename" command="basename">
    <needs-terminal/>
    <summary xml:lang="en">Basename: strip directory and suffix from filenames</summary>
    <description xml:lang="en">Print   NAME   with  any  leading  directory  components
       removed.  If specified, also remove a trailing SUFFIX.</description>
  </entry-point><entry-point binary-name="cat" command="cat">
    <needs-terminal/>
    <summary xml:lang="en">Cat: concatenate files and print on the standard output</summary>
    <description xml:lang="en">Concatenate FILE(s), or standard input, to standard out-
       put.</description>
  </entry-point><entry-point binary-name="chgrp" command="chgrp">
    <needs-terminal/>
    <summary xml:lang="en">Chgrp: change group ownership</summary>
    <description xml:lang="en">Change  the  group of each FILE to GROUP.  With --refer-
       ence, change the group of each FILE to that of RFILE.</description>
  </entry-point><entry-point binary-name="chmod" command="chmod">
    <needs-terminal/>
    <summary xml:lang="en">Chmod: change file access permissions</summary>
    <description xml:lang="en">chmod changes the permissions of each given file accord-
       ing  to mode, which can be either a symbolic representa-
       tion of changes to make, or an octal number representing
       the bit pattern for the new permissions.</description>
  </entry-point><entry-point binary-name="chown" command="chown">
    <needs-terminal/>
    <summary xml:lang="en">Chown: change file owner and group</summary>
    <description xml:lang="en">chown changes the user and/or group  ownership  of  each
       given  file, according to its first non-option argument,
       which is interpreted as follows.  If only  a  user  name
       (or  numeric  user  ID)  is given, that user is made the
       owner of each given file, and the files'  group  is  not
       changed.  If the user name is followed by a colon or dot
       and a group name (or numeric group ID), with  no  spaces
       between  them,  the  group  ownership  of  the  files is
       changed as well.  If a colon or dot but  no  group  name
       follows  the  user  name, that user is made the owner of
       the files and the group of the files is changed to  that
       user's  login  group.  If the colon or dot and group are
       given, but the user name is omitted, only the  group  of
       the  files  is changed; in this case, chown performs the
       same function as chgrp.</description>
  </entry-point><entry-point binary-name="chroot" command="chroot">
    <needs-terminal/>
    <summary xml:lang="en">Chroot: run command or interactive shell with special root directory</summary>
    <description xml:lang="en">Run COMMAND with root directory set to NEWROOT.</description>
  </entry-point><entry-point binary-name="cksum" command="cksum">
    <needs-terminal/>
    <summary xml:lang="en">Cksum: checksum and count the bytes in a file</summary>
    <description xml:lang="en">Print CRC checksum and byte counts of each FILE.</description>
  </entry-point><entry-point binary-name="comm" command="comm">
    <needs-terminal/>
    <summary xml:lang="en">Comm: compare two sorted files line by line</summary>
    <description xml:lang="en">Compare sorted files FILE1 and FILE2 line by line.

       With  no  options,  produce three-column output.  Column
       one contains lines unique to FILE1, column two  contains
       lines  unique  to FILE2, and column three contains lines
       common to both files.</description>
  </entry-point><entry-point binary-name="cp" command="cp">
    <needs-terminal/>
    <summary xml:lang="en">Cp: copy files and directories</summary>
    <description xml:lang="en">Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</description>
  </entry-point><entry-point binary-name="csplit" command="csplit">
    <needs-terminal/>
    <summary xml:lang="en">Csplit: split a file into sections determined by context lines</summary>
    <description xml:lang="en">Output pieces of FILE separated by PATTERN(s)  to  files
       `xx01',  `xx02',  ...,  and  output  byte counts of each
       piece to standard output.</description>
  </entry-point><entry-point binary-name="cut" command="cut">
    <needs-terminal/>
    <summary xml:lang="en">Cut: remove sections from each line of files</summary>
    <description xml:lang="en">Print selected parts of lines from each FILE to standard
       output.</description>
  </entry-point><entry-point binary-name="date" command="date">
    <needs-terminal/>
    <summary xml:lang="en">Date: print or set the system date and time</summary>
    <description xml:lang="en">Display the current time in the given FORMAT, or set the
       system date.</description>
  </entry-point><entry-point binary-name="dd" command="dd">
    <needs-terminal/>
    <summary xml:lang="en">Dd: convert and copy a file</summary>
    <description xml:lang="en">Copy  a file, converting and formatting according to the
       operands.</description>
  </entry-point><entry-point binary-name="df" command="df">
    <needs-terminal/>
    <summary xml:lang="en">Df: report filesystem disk space usage</summary>
    <description xml:lang="en"> df
       displays the amount of disk space available on the  file
       system  containing  each file name argument.  If no file
       name is given, the  space  available  on  all  currently
       mounted  file  systems is shown.  Disk space is shown in
       1K blocks by default, unless  the  environment  variable
       POSIXLY_CORRECT  is  set,  in which case 512-byte blocks
       are used.</description>
  </entry-point><entry-point binary-name="dir" command="dir">
    <needs-terminal/>
    <summary xml:lang="en">Dir: list directory contents</summary>
    <description xml:lang="en">List  information about the FILEs (the current directory
       by default).  Sort entries  alphabetically  if  none  of
       -cftuSUX nor --sort.</description>
  </entry-point><entry-point binary-name="dircolors" command="dircolors">
    <needs-terminal/>
    <summary xml:lang="en">DirColors: color setup for ls</summary>
    <description xml:lang="en">Output  commands  to set the LS_COLORS environment vari-
       able.</description>
  </entry-point><entry-point binary-name="dirname" command="dirname">
    <needs-terminal/>
    <summary xml:lang="en">Dirname: strip non-directory suffix from file name</summary>
    <description xml:lang="en">Print NAME with its trailing /component removed; if NAME
       contains no /'s, output `.' (meaning the current  direc-
       tory).</description>
  </entry-point><entry-point binary-name="du" command="du">
    <needs-terminal/>
    <summary xml:lang="en">Du: estimate file space usage</summary>
    <description xml:lang="en">Summarize  disk  usage  of  each  FILE,  recursively for
       directories.</description>
  </entry-point><entry-point binary-name="echo" command="echo">
    <needs-terminal/>
    <summary xml:lang="en">Echo: display a line of text</summary>
    <description xml:lang="en">Echo the STRING(s) to standard output.
</description>
  </entry-point><entry-point binary-name="env" command="env">
    <needs-terminal/>
    <summary xml:lang="en">Env: run a program in a modified environment</summary>
    <description xml:lang="en">Set  each  NAME to VALUE in the environment and run COM-
       MAND.</description>
  </entry-point><entry-point binary-name="expand" command="expand">
    <needs-terminal/>
    <summary xml:lang="en">Expand: convert tabs to spaces</summary>
    <description xml:lang="en">Convert tabs in each FILE to spaces, writing to standard
       output.  With no FILE, or when FILE is -, read  standard
       input.</description>
  </entry-point><entry-point binary-name="expr" command="expr">
    <needs-terminal/>
    <summary xml:lang="en">Expr: evaluate expressions</summary>
    <description xml:lang="en">Print  the  value  of  EXPRESSION to standard output.  A
       blank line below separates increasing precedence groups.</description>
  </entry-point><entry-point binary-name="factor" command="factor">
    <needs-terminal/>
    <summary xml:lang="en">Factor: factor numbers</summary>
    <description xml:lang="en">Print the prime factors of each NUMBER.</description>
  </entry-point><entry-point binary-name="false" command="false">
    <needs-terminal/>
    <summary xml:lang="en">False: do nothing, unsuccessfully</summary>
    <description xml:lang="en">Exit with a status code indicating failure.</description>
  </entry-point><entry-point binary-name="fmt" command="fmt">
    <needs-terminal/>
    <summary xml:lang="en">Fmt: simple optimal text formatter</summary>
    <description xml:lang="en">Reformat each paragraph in the FILE(s), writing to stan-
       dard output.  If no FILE or if FILE is `-',  read  stan-
       dard input.</description>
  </entry-point><entry-point binary-name="fold" command="fold">
    <needs-terminal/>
    <summary xml:lang="en">Fold: wrap each input line to fit in specified width</summary>
    <description xml:lang="en">Wrap  input  lines  in  each  FILE  (standard  input  by
       default), writing to standard output.</description>
  </entry-point><entry-point binary-name="gdate" command="gdate">
    <needs-terminal/>
    <summary xml:lang="en">Date: print or set the system date and time</summary>
    <description xml:lang="en">Display the current time in the given FORMAT, or set the
       system date.</description>
  </entry-point><entry-point binary-name="gecho" command="gecho">
    <needs-terminal/>
    <summary xml:lang="en">Echo: display a line of text</summary>
    <description xml:lang="en">Echo the STRING(s) to standard output.</description>
  </entry-point><entry-point binary-name="ginstall" command="ginstall">
    <needs-terminal/>
    <summary xml:lang="en">Install: copy files and set attributes</summary>
    <description xml:lang="en">In  the first three forms, copy SOURCE to DEST or multi-
       ple SOURCE(s) to the existing DIRECTORY,  while  setting
       permission modes and owner/group.  In the 4th form, cre-
       ate all components of the given DIRECTORY(ies).</description>
  </entry-point><entry-point binary-name="gln" command="gln">
    <needs-terminal/>
    <summary xml:lang="en">Ln: make links between files</summary>
    <description xml:lang="en">In  the  1st form, create a link to TARGET with the name
       LINK_NAME.  In the 2nd form, create a link to TARGET  in
       the current directory.  In the 3rd and 4th forms, create
       links to each TARGET in DIRECTORY.  Create hard links by
       default,  symbolic links with --symbolic.  When creating
       hard links, each TARGET must exist.</description>
  </entry-point><entry-point binary-name="gmkdir" command="gmkdir">
    <needs-terminal/>
    <summary xml:lang="en">Mkdir:  make directories</summary>
    <description xml:lang="en">Create the DIRECTORY(ies), if they do not already exist.</description>
  </entry-point><entry-point binary-name="grmdir" command="grmdir">
    <needs-terminal/>
    <summary xml:lang="en">Rmdir: remove empty directories</summary>
    <description xml:lang="en">Remove the DIRECTORY(ies), if they are empty.</description>
  </entry-point><entry-point binary-name="groups" command="groups">
    <needs-terminal/>
    <name xml:lang="en">groups</name>
    <summary xml:lang="en">groups - print the groups a user is in</summary>
    <description xml:lang="en">Same as id -Gn.  If no USERNAME, use current process.</description>
  </entry-point><entry-point binary-name="gsort" command="gsort">
    <needs-terminal/>
    <summary xml:lang="en">Sort: sort lines of text files</summary>
    <description xml:lang="en">Write  sorted  concatenation  of all FILE(s) to standard
       output.</description>
  </entry-point><entry-point binary-name="head" command="head">
    <needs-terminal/>
    <summary xml:lang="en">Head: output the first part of files</summary>
    <description xml:lang="en">Print  the  first 10 lines of each FILE to standard out-
       put.  With more than  one  FILE,  precede  each  with  a
       header giving the file name.  With no FILE, or when FILE
       is -, read standard input.</description>
  </entry-point><entry-point binary-name="hostid" command="hostid">
    <needs-terminal/>
    <summary xml:lang="en">Hostid: print the numeric identifier for the current host</summary>
    <description xml:lang="en">Print the numeric identifier (in  hexadecimal)  for  the
       current host.</description>
  </entry-point><entry-point binary-name="hostname" command="hostname">
    <needs-terminal/>
    <summary xml:lang="en">Hostname: set or print the name of the current host system</summary>
    <description xml:lang="en">Print or set the hostname of the current system.</description>
  </entry-point><entry-point binary-name="id" command="id">
    <needs-terminal/>
    <summary xml:lang="en">Id: print real and effective UIDs and GIDs</summary>
    <description xml:lang="en">Print information for USERNAME, or the current user.</description>
  </entry-point><entry-point binary-name="join" command="join">
    <needs-terminal/>
    <summary xml:lang="en">Join: join lines of two files on a common field</summary>
    <description xml:lang="en"> For each pair of input lines with identical join fields,
       write a line to standard output.  The default join field
       is  the  first,  delimited by whitespace.  When FILE1 or
       FILE2 (not both) is -, read standard input.</description>
  </entry-point><entry-point binary-name="kill" command="kill">
    <needs-terminal/>
    <summary xml:lang="en">Kill: send signals to processes, or list signals</summary>
    <description xml:lang="en">Send signals to processes, or list signals.</description>
  </entry-point><entry-point binary-name="link" command="link">
    <needs-terminal/>
    <summary xml:lang="en">Link: call the link function to create a link to a file</summary>
    <description xml:lang="en">Call the link function to create a link named  FILE2  to
       an existing FILE1.</description>
  </entry-point><entry-point binary-name="ln" command="ln">
    <needs-terminal/>
    <summary xml:lang="en">Ln: make links between files</summary>
    <description xml:lang="en">In  the  1st form, create a link to TARGET with the name
       LINK_NAME.  In the 2nd form, create a link to TARGET  in
       the current directory.  In the 3rd and 4th forms, create
       links to each TARGET in DIRECTORY.  Create hard links by
       default,  symbolic links with --symbolic.  When creating
       hard links, each TARGET must exist.</description>
  </entry-point><entry-point binary-name="logname" command="logname">
    <needs-terminal/>
    <summary xml:lang="en">Logname: print user's login name</summary>
    <description xml:lang="en">Print the name of the current user.</description>
  </entry-point><entry-point binary-name="ls" command="ls">
    <needs-terminal/>
    <summary xml:lang="en">Ls: list directory contents</summary>
    <description xml:lang="en">List  information about the FILEs (the current directory
       by default).  Sort entries  alphabetically  if  none  of
       -cftuSUX nor --sort.</description>
  </entry-point><entry-point binary-name="md5sum" command="md5sum">
    <needs-terminal/>
    <summary xml:lang="en">Md5Sum: compute and check MD5 message digest</summary>
    <description xml:lang="en">Print  or  check MD5 (128-bit) checksums.  With no FILE,
       or when FILE is -, read standard input.</description>
  </entry-point><entry-point binary-name="mkdir" command="mkdir">
    <needs-terminal/>
    <summary xml:lang="en">Mkdir:  make directories</summary>
    <description xml:lang="en">Create the DIRECTORY(ies), if they do not already exist.</description>
  </entry-point><entry-point binary-name="mkfifo" command="mkfifo">
    <needs-terminal/>
    <summary xml:lang="en">Mkfifo: make FIFOs (named pipes)</summary>
    <description xml:lang="en">Create named pipes (FIFOs) with the given NAMEs.</description>
  </entry-point><entry-point binary-name="mknod" command="mknod">
    <needs-terminal/>
    <summary xml:lang="en">Mknod:  make block or character special files</summary>
    <description xml:lang="en">Create the special file NAME of the given TYPE.</description>
  </entry-point><entry-point binary-name="mv" command="mv">
    <needs-terminal/>
    <summary xml:lang="en">Mv: move (rename) files</summary>
    <description xml:lang="en">Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.</description>
  </entry-point><entry-point binary-name="nice" command="nice">
    <needs-terminal/>
    <summary xml:lang="en">Nice: run a program with modified scheduling priority</summary>
    <description xml:lang="en">Run  COMMAND  with an adjusted nice value, which affects
       the scheduling priority.  With  no  COMMAND,  print  the
       current  nice  value.   Nice values range from -20 (most
       favorable scheduling) to 19 (least favorable).</description>
  </entry-point><entry-point binary-name="nl" command="nl">
    <needs-terminal/>
    <summary xml:lang="en">Nl: number lines of files</summary>
    <description xml:lang="en">Write  each  FILE  to standard output, with line numbers
       added.  With no FILE, or when FILE is -,  read  standard
       input.</description>
  </entry-point><entry-point binary-name="nohup" command="nohup">
    <needs-terminal/>
    <summary xml:lang="en">Nohup: run a command immune to hangups, with output to a non-tty</summary>
    <description xml:lang="en">Run COMMAND, ignoring hangup signals.</description>
  </entry-point><entry-point binary-name="od" command="od">
    <needs-terminal/>
    <summary xml:lang="en">Od: dump files in octal and other formats</summary>
    <description xml:lang="en">Write an  unambiguous  representation,  octal  bytes  by
       default, of FILE to standard output.  With more than one
       FILE argument, concatenate them in the listed  order  to
       form  the  input.  With no FILE, or when FILE is -, read
       standard input.</description>
  </entry-point><entry-point binary-name="paste" command="paste">
    <needs-terminal/>
    <summary xml:lang="en">Paste: merge lines of files</summary>
    <description xml:lang="en">Write lines consisting of the sequentially corresponding
       lines from each FILE, separated  by  TABs,  to  standard
       output.   With no FILE, or when FILE is -, read standard
       input.</description>
  </entry-point><entry-point binary-name="pathchk" command="pathchk">
    <needs-terminal/>
    <summary xml:lang="en">Pathchk: check whether file names are valid or portable</summary>
    <description xml:lang="en">Diagnose unportable constructs in NAME.</description>
  </entry-point><entry-point binary-name="pinky" command="pinky">
    <needs-terminal/>
    <summary xml:lang="en">Pinky: lightweight finger</summary>
    <description xml:lang="en">A lightweight `finger' program;  print user information.</description>
  </entry-point><entry-point binary-name="pr" command="pr">
    <needs-terminal/>
    <summary xml:lang="en">Pr: convert text files for printing</summary>
    <description xml:lang="en">Paginate or columnate FILE(s) for printing.</description>
  </entry-point><entry-point binary-name="printenv" command="printenv">
    <needs-terminal/>
    <summary xml:lang="en">Printenv: print all or part of environment</summary>
    <description xml:lang="en">If no environment VARIABLE specified, print them all.</description>
  </entry-point><entry-point binary-name="printf" command="printf">
    <needs-terminal/>
    <summary xml:lang="en">Printf: format and print data</summary>
    <description xml:lang="en">Print ARGUMENT(s) according to FORMAT.</description>
  </entry-point><entry-point binary-name="ptx" command="ptx">
    <needs-terminal/>
    <summary xml:lang="en">Ptx: produce a permuted index of file contents</summary>
    <description xml:lang="en"> Output a permuted index, including context, of the words
       in the input files.</description>
  </entry-point><entry-point binary-name="pwd" command="pwd">
    <needs-terminal/>
    <summary xml:lang="en">Pwd: print name of current/working directory</summary>
    <description xml:lang="en">Print the full filename of the  current  working  direc-
       tory.</description>
  </entry-point><entry-point binary-name="readlink" command="readlink">
    <needs-terminal/>
    <summary xml:lang="en">Readlink: display value of a symbolic link</summary>
    <description xml:lang="en">Display value of a symbolic link on standard output.</description>
  </entry-point><entry-point binary-name="rm" command="rm">
    <needs-terminal/>
    <summary xml:lang="en">Rm: remove files or directories</summary>
    <description xml:lang="en"> rm
       removes each specified file.  By default,  it  does  not
       remove directories.</description>
  </entry-point><entry-point binary-name="rmdir" command="rmdir">
    <needs-terminal/>
    <summary xml:lang="en">Rmdir: remove empty directories</summary>
    <description xml:lang="en">Remove the DIRECTORY(ies), if they are empty.</description>
  </entry-point><entry-point binary-name="seq" command="seq">
    <needs-terminal/>
    <summary xml:lang="en">Seq: print a sequence of numbers</summary>
    <description xml:lang="en">Print numbers from FIRST to LAST, in steps of INCREMENT.</description>
  </entry-point><entry-point binary-name="setuidgid" command="setuidgid">
    <needs-terminal/>
    <summary xml:lang="en">Setuidgid: run a command as a specified user</summary>
    <description xml:lang="en">Drop any supplemental groups, assume the user-ID and group-ID of
the specified USERNAME, and run COMMAND with any specified ARGUMENTs.
Exit with status 111 if unable to assume the required UID and GID.
Otherwise, exit with the exit status of COMMAND.
This program is useful only when run by root (UID=0).</description>
  </entry-point><entry-point binary-name="sha1sum" command="sha1sum">
    <needs-terminal/>
    <summary xml:lang="en">Sha1sum: compute and check SHA1 message digest</summary>
    <description xml:lang="en">Print  or check SHA1 (160-bit) checksums.  With no FILE,
       or when FILE is -, read standard input.</description>
  </entry-point><entry-point binary-name="shred" command="shred">
    <needs-terminal/>
    <summary xml:lang="en">Shred: delete a file securely</summary>
    <description xml:lang="en">Overwrite the specified FILE(s) repeatedly, in order  to
       make  it harder for even very expensive hardware probing
       to recover the data.</description>
  </entry-point><entry-point binary-name="sleep" command="sleep">
    <needs-terminal/>
    <summary xml:lang="en">Sleep: delay for a specified amount of time</summary>
    <description xml:lang="en">Pause for NUMBER seconds.  SUFFIX may be `s' for seconds
       (the default), `m' for minutes, `h' for hours or `d' for
       days.   Unlike  most implementations that require NUMBER
       be an integer, here NUMBER may be an arbitrary  floating
       point number.</description>
  </entry-point><entry-point binary-name="sort" command="sort">
    <needs-terminal/>
    <summary xml:lang="en">Sort: sort lines of text files</summary>
    <description xml:lang="en">Write  sorted  concatenation  of all FILE(s) to standard
       output.</description>
  </entry-point><entry-point binary-name="split" command="split">
    <needs-terminal/>
    <summary xml:lang="en">Split: split a file into pieces</summary>
    <description xml:lang="en">Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab,
       ...; default PREFIX is `x'.   With  no  INPUT,  or  when
       INPUT is -, read standard input.</description>
  </entry-point><entry-point binary-name="stat" command="stat">
    <needs-terminal/>
    <summary xml:lang="en">Stat: display file or filesystem status</summary>
    <description xml:lang="en">Display file or file system status.</description>
  </entry-point><entry-point binary-name="stty" command="stty">
    <needs-terminal/>
    <summary xml:lang="en">Stty: change and print terminal line settings</summary>
    <description xml:lang="en">Print or change terminal characteristics.</description>
  </entry-point><entry-point binary-name="su" command="su">
    <needs-terminal/>
    <summary xml:lang="en">Su: run a shell with substitute user and group IDs</summary>
    <description xml:lang="en">Change  the  effective  user  id and group id to that of
       USER.</description>
  </entry-point><entry-point binary-name="sum" command="sum">
    <needs-terminal/>
    <summary xml:lang="en">Sum: checksum and count the blocks in a file</summary>
    <description xml:lang="en">Print checksum and block counts for each FILE.</description>
  </entry-point><entry-point binary-name="sync" command="sync">
    <needs-terminal/>
    <summary xml:lang="en">Sync: flush filesystem buffers</summary>
    <description xml:lang="en">Force changed blocks to disk, update the super block.</description>
  </entry-point><entry-point binary-name="tac" command="tac">
    <needs-terminal/>
    <summary xml:lang="en">Tac: concatenate and print files in reverse</summary>
    <description xml:lang="en">Write  each  FILE  to  standard output, last line first.
       With no FILE, or when FILE is -, read standard input.</description>
  </entry-point><entry-point binary-name="tail" command="tail">
    <needs-terminal/>
    <summary xml:lang="en">Tail: output the last part of files</summary>
    <description xml:lang="en">Print the last 10 lines of each FILE to standard output.
       With more than one FILE, precede each with a header giv-
       ing  the  file  name.   With no FILE, or when FILE is -,
       read standard input.</description>
  </entry-point><entry-point binary-name="tee" command="tee">
    <needs-terminal/>
    <summary xml:lang="en">Tee: read from standard input and write to standard output and files</summary>
    <description xml:lang="en">Copy standard input to each FILE, and also  to  standard
       output.</description>
  </entry-point><entry-point binary-name="test" command="test">
    <needs-terminal/>
    <summary xml:lang="en">Test: check file types and compare values</summary>
    <description xml:lang="en">Exit with the status determined by EXPRESSION.</description>
  </entry-point><entry-point binary-name="touch" command="touch">
    <needs-terminal/>
    <summary xml:lang="en">Touch: change file timestamps</summary>
    <description xml:lang="en">Update the access and modification times of each FILE to
       the current time.</description>
  </entry-point><entry-point binary-name="tr" command="tr">
    <needs-terminal/>
    <summary xml:lang="en">Tr: translate or delete characters</summary>
    <description xml:lang="en">Translate,  squeeze, and/or delete characters from stan-
       dard input, writing to standard output.</description>
  </entry-point><entry-point binary-name="true" command="true">
    <needs-terminal/>
    <summary xml:lang="en">True: do nothing, successfully</summary>
    <description xml:lang="en">Exit with a status code indicating success.</description>
  </entry-point><entry-point binary-name="tsort" command="tsort">
    <needs-terminal/>
    <summary xml:lang="en">Tsort: perform topological sort</summary>
    <description xml:lang="en">Write  totally  ordered list consistent with the partial
       ordering in FILE.  With no FILE, or when FILE is -, read
       standard input.</description>
  </entry-point><entry-point binary-name="tty" command="tty">
    <needs-terminal/>
    <summary xml:lang="en">Tty: print the file name of the terminal connected to standard input</summary>
    <description xml:lang="en">Print the file name of the terminal connected  to  stan-
       dard input.</description>
  </entry-point><entry-point binary-name="uname" command="uname">
    <needs-terminal/>
    <summary xml:lang="en">Uname: print system information</summary>
    <description xml:lang="en">Print  certain system information.  With no OPTION, same
       as -s.</description>
  </entry-point><entry-point binary-name="unexpand" command="unexpand">
    <needs-terminal/>
    <summary xml:lang="en">Unexpand: convert spaces to tabs</summary>
    <description xml:lang="en">       Convert blanks in each FILE to tabs, writing to standard
       output.  With no FILE, or when FILE is -, read  standard
       input.</description>
  </entry-point><entry-point binary-name="uniq" command="uniq">
    <needs-terminal/>
    <summary xml:lang="en">Uniq: remove duplicate lines from a sorted file</summary>
    <description xml:lang="en">Discard  all  but one of successive identical lines from
       INPUT (or standard input), writing to OUTPUT  (or  stan-
       dard output).</description>
  </entry-point><entry-point binary-name="unlink" command="unlink">
    <needs-terminal/>
    <summary xml:lang="en">Unlink: call the unlink function to remove the specified file</summary>
    <description xml:lang="en">Call the unlink function to remove the specified FILE.</description>
  </entry-point><entry-point binary-name="uptime" command="uptime">
    <needs-terminal/>
    <summary xml:lang="en">Uptime: tell how long the system has been running</summary>
    <description xml:lang="en">Print  the  current  time, the length of time the system
       has been up, the number of users on the system, and  the
       average number of jobs in the run queue over the last 1,
       5 and  15  minutes.   If  FILE  is  not  specified,  use
       /var/run/utmp.  /var/log/wtmp as FILE is common.</description>
  </entry-point><entry-point binary-name="users" command="users">
    <needs-terminal/>
    <summary xml:lang="en">Users: print the user names of users currently logged in to the current host</summary>
    <description xml:lang="en">Output who is currently logged in according to FILE.  If
       FILE is not specified, use /var/run/utmp.  /var/log/wtmp
       as FILE is common.</description>
  </entry-point><entry-point binary-name="vdir" command="vdir">
    <needs-terminal/>
    <summary xml:lang="en">Vdir: list directory contents</summary>
    <description xml:lang="en">List  information about the FILEs (the current directory
       by default).  Sort entries  alphabetically  if  none  of
       -cftuSUX nor --sort.</description>
  </entry-point><entry-point binary-name="wc" command="wc">
    <needs-terminal/>
    <summary xml:lang="en">Wc: print the number of bytes, words, and lines in files</summary>
    <description xml:lang="en">Print newline, word, and byte counts for each FILE,  and
       a  total  line if more than one FILE is specified.  With
       no FILE, or when FILE is -, read standard input.</description>
  </entry-point><entry-point binary-name="who" command="who">
    <needs-terminal/>
    <summary xml:lang="en">Who: show who is logged on</summary>
  </entry-point><entry-point binary-name="whoami" command="whoami">
    <needs-terminal/>
    <summary xml:lang="en">Whoami: print effective userid</summary>
    <description xml:lang="en">Print  the  user name associated with the current effec-
       tive user id.  Same as id -un.</description>
  </entry-point><entry-point binary-name="yes" command="yes">
    <needs-terminal/>
    <summary xml:lang="en">Yes: output a string repeatedly until killed</summary>
    <description xml:lang="en">Repeatedly  output  a line with all specified STRING(s),
       or `y'.</description>
  </entry-point><entry-point binary-name="[" command="[">
    <needs-terminal/>
    <summary xml:lang="en">[: test expression</summary>
    <description xml:lang="en">Exit with the status determined by EXPRESSION.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/cpio.xml"><name>Cpio</name><summary xml:lang="en">Cpio: copy files to and from archives</summary><description xml:lang="en">GNU cpio copies files into or out of a cpio or tar archive. The archive can be another file on the disk, a magnetic tape, or a pipe. 

GNU cpio supports the following archive formats: binary, old ASCII, new ASCII, crc, HPUX binary, HPUX old ASCII, old tar, and POSIX.1 tar. The tar format is provided for compatibility with the tar program. By default, cpio creates binary format archives for compatibility with older cpio programs. When extracting from archives, cpio automatically recognizes which kind of archive it is reading and can read archives created on machines with a different byte-order. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/cpio.htm</homepage><entry-point binary-name="cpio" command="run"/></interface><interface uri="https://apps.0install.net/utils/diffutils.xml"><name>DiffUtils</name><summary xml:lang="en">show differences between files</summary><description xml:lang="en">You can use the diff command to show differences between two files, or each corresponding file in two directories. diff outputs differences between files line by line in any of several formats, selectable by command line options. This set of differences is often called a `diff' or `patch'. For files that are identical, diff normally produces no output; for binary (non-text) files, diff normally reports only that they are different. 

You can use the cmp command to show the offsets and line numbers where two files differ. cmp can also show all the characters that differ between the two files, side by side. 

You can use the diff3 command to show differences among three files. When two people have made independent changes to a common original, diff3 can report the differences between the original and the two changed versions, and can produce a merged file that contains both persons' changes together with warnings about conflicts. 

You can use the sdiff command to merge two files interactively. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>System</category><homepage>http://gnuwin32.sourceforge.net/packages/diffutils.htm</homepage><entry-point binary-name="diff" command="run">
    <needs-terminal/>
    <name xml:lang="en">Diff</name>
    <summary xml:lang="en">Diff: find differences between two files</summary>
    <description xml:lang="en">In  the simplest case, diff compares the contents of the
       two files from-file and  to-file.   A  file  name  of  -
       stands for text read from the standard input.  As a spe-
       cial case, diff - - compares a copy of standard input to
       itself.</description>
  </entry-point><entry-point binary-name="cmp" command="cmp">
    <needs-terminal/>
    <name xml:lang="en">Cmp</name>
    <summary xml:lang="en">Cmp: compare two files byte by byte</summary>
    <description xml:lang="en">Compare two files byte by byte.</description>
  </entry-point><entry-point binary-name="diff3" command="diff3">
    <needs-terminal/>
    <name xml:lang="en">Diff3</name>
    <summary xml:lang="en">Diff3: compare three files line by line</summary>
    <description xml:lang="en">Compare three files line by line.</description>
  </entry-point><entry-point binary-name="sdiff" command="sdiff">
    <needs-terminal/>
    <name xml:lang="en">Sdiff</name>
    <summary xml:lang="en">Sdiff: side-by-side merge of file differences</summary>
    <description xml:lang="en">Side-by-side merge of file differences.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/dmidecode.xml"><name>DmiDecode</name><summary xml:lang="en">Dmidecode: DMI-table decoder</summary><description xml:lang="en">Dmidecode reports information about your system's hardware as described in your system BIOS according to the SMBIOS/DMI standard. This information typically includes system manufacturer, model name, serial number, BIOS version, asset tag as well as a lot of other details of varying level of interest and reliability depending on the manufacturer. This will often include usage status for the CPU sockets, expansion slots (e.g. AGP, PCI, ISA) and memory module slots, and the list of I/O ports (e.g. serial, parallel, USB). 
Beware that DMI data have proven to be too unreliable to be blindly trusted. Dmidecode does not scan your hardware, it only reports what the BIOS told it to. 
Three additional tools come with dmidecode: 
•biosdecode prints all BIOS related information it can find 
•ownership retrieves the &quot;ownership tag&quot; that can be set on Compaq computers 
•vpddecode prints the &quot;vital product data&quot; information that can be found in almost all IBM computers 
This MS-Windows port is based on the patches created by Hugo Weber &lt;http://lists.gnu.org/archive/html/dmidecode-devel/2006-10/msg00001.html&gt;. It works only on MS-Windows NT systems (NT, 2000, XP, 2003, Vista, 2008) and not on MS-Windows 9x systems (95, 98, ME). 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/dmidecode.htm</homepage><entry-point binary-name="dmidecode" command="run">
    <needs-terminal/>
    <summary xml:lang="en">dmidecode - DMI table decoder</summary>
    <description xml:lang="en">dmidecode  is  a tool for dumping a computer's DMI (some
       say SMBIOS) table contents in a  human-readable  format.
       This  table contains a description of the system's hard-
       ware components, as  well  as  other  useful  pieces  of
       information  such  as  serial numbers and BIOS revision.
       Thanks to this table, you can retrieve this  information
       without  having to probe for the actual hardware.  While
       this is a good point in terms of report speed and  safe-
       ness, this also makes the presented information possibly
       unreliable.

       The DMI table doesn't only describe what the  system  is
       currently  made of, it also can report the possible evo-
       lutions (such as the fastest supported CPU or the  maxi-
       mal amount of memory supported).

       SMBIOS  stands  for  System  Management  BIOS, while DMI
       stands for Desktop Management Interface. Both  standards
       are  tightly  related and developed by the DMTF (Desktop
       Management Task Force).

       As you run it, dmidecode will try to locate the DMI  ta-
       ble.  If  it succeeds, it will then parse this table and
       display a list of records like this one:

       Handle 0x0002, DMI type 2, 8 bytes.  Base Board Informa-
       tion
               Manufacturer: Intel
               Product Name: C440GX+
               Version: 727281-001
               Serial Number: INCY92700942

       Each record has:

       · A  handle.  This  is a unique identifier, which allows
         records to reference each other. For example,  proces-
         sor  records  usually  reference  cache memory records
         using their handles.

       · A type. The  SMBIOS  specification  defines  different
         types  of  elements a computer can be made of. In this
         example, the type is 2, which means  that  the  record
         contains &quot;Base Board Information&quot;.

       · A  size.  Each  record  has a 4-byte header (2 for the
         handle, 1 for the type, 1 for the size), the  rest  is
         used  by the record data. This value doesn't take text
         strings into account (these are placed at the  end  of
         the record), so the actual length of the record may be
         (and is often) greater than the displayed value.

       · Decoded values. The information  presented  of  course
         depends  on  the  type of record. Here, we learn about
         the board's manufacturer, model,  version  and  serial
         number.</description>
  </entry-point><entry-point binary-name="biosdecode" command="biosdecode">
    <needs-terminal/>
    <summary xml:lang="en">Biosdecode: BIOS-information decoder</summary>
    <description xml:lang="en">biosdecode parses the BIOS memory and prints information
       about all structures (or entry points) it knows of. Cur-
       rently known entry point types are:

       · SMBIOS (System Management BIOS)
         Use dmidecode for a more detailed output.

       · DMI (Desktop Management Interface, a legacy version of
         SMBIOS)
         Use dmidecode for a more detailed output.

       · SYSID

       · PNP (Plug and Play)

       · ACPI (Advanced Configuration and Power Interface)

       · BIOS32 (BIOS32 Service Directory)

       · PIR (PCI IRQ Routing)

       · 32OS (BIOS32 Extension, Compaq-specific)
         See ownership for a  Compaq  ownership  tag  retrieval
         tool.

       · SNY (Sony-specific, not decoded)

       · VPD (Vital Product Data, IBM-specific)
         Use vpddecode for a more detailed output.

       · FJKEYINF (Application Panel, Fujitsu-specific)


       biosdecode  started  its life as a part of dmidecode but
       as more entry point types were added, if was moved to  a
       different program.</description>
  </entry-point><entry-point binary-name="ownership" command="ownership">
    <needs-terminal/>
    <summary xml:lang="en">Ownership: Compaq ownership-tag retriever</summary>
    <description xml:lang="en">ownership  retrieves and prints the &quot;ownership tag&quot; that
       can be set on Compaq computers. Contrary  to  all  other
       programs  of  the  dmidecode  package, ownership doesn't
       print any version information, nor labels, but only  the
       raw  ownership  tag. This should help its integration in
       scripts.</description>
  </entry-point><entry-point binary-name="vpddecode" command="vpddecode">
    <needs-terminal/>
    <name xml:lang="en">Vpddecode</name>
    <summary xml:lang="en">Vpddecode: VPD-structure decoder</summary>
    <description xml:lang="en">vpddecode  prints  the  &quot;vital product data&quot; information
       that can be found in almost all IBM and  Lenovo  comput-
       ers. Available items are:

       · BIOS Build ID

       · Box Serial Number

       · Motherboard Serial Number

       · Machine Type/Model


       Some systems have these additional items:

       · BIOS Release Date

       · Default Flash Image File Name


       Note  that  these additional items are not documented by
       IBM, so this is guess work, and as such  should  not  be
       blindly  trusted.  Feedback  about the accuracy of these
       labels is welcome.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/ed.xml"><name>Ed</name><summary xml:lang="en">Ed: line-oriented text editor</summary><description xml:lang="en">`ed' is a line-oriented text editor. It is used to create, display, modify and otherwise manipulate text files, both interactively and via shell scripts. A restricted version of `ed', `red', can only edit files in the current directory and cannot execute shell commands. `ed' is the `standard' text editor in the sense that it is the original editor for Unix, and thus widely available. For most purposes, however, it is superseded by full-screen editors such as Emacs. </description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/ed.htm</homepage><entry-point binary-name="ed" command="run"/></interface><interface uri="https://apps.0install.net/utils/ffmpeg.xml"><name>FFmpeg</name><summary>record, convert and stream audio and video</summary><description>A complete, cross-platform solution to record, convert and stream audio and video.</description><category>Utility</category><homepage>http://ffmpeg.org/</homepage><entry-point binary-name="ffmpeg" command="run"/><entry-point binary-name="ffplay" command="ffplay">
    <needs-terminal/>
    <name>FFplay</name>
    <summary>very simple and portable media player</summary>
    <description>FFplay is a very simple and portable media player using the FFmpeg libraries and the SDL library. It is mostly used as a testbed for the various FFmpeg APIs.</description>
  </entry-point><entry-point binary-name="ffprobe" command="ffprobe">
    <needs-terminal/>
    <name>FFprobe</name>
    <summary>gathers information from multimedia streams</summary>
    <description>ffprobe gathers information from multimedia streams and prints it in human- and machine-readable fashion.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/fatattr.xml"><name>FatAttr</name><summary xml:lang="en">Fatattr: Display or change attributes on a filesystem</summary><description xml:lang="en">fatattr displays or changes attributes on an MS-DOS FAT
       filesystem. If only a list of files (or directories)
       are given, it displays the attributes for those files or
       directories. If given a list of attributes, it will add
       (+) or remove (-) the  specified attributes from the
       given list of files or directories.</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/util-linux-ng.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/util-linux-ng.png" type="image/png"/><category>System</category><homepage>https://sourceforge.net/projects/gnuwin32/files/fatattr/</homepage><entry-point binary-name="fatattr" command="run">
    <needs-terminal/>
    <name xml:lang="en">Fatattr</name>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/file.xml"><name>File</name><summary xml:lang="en">File: determine file type</summary><description xml:lang="en">The latest GnuWin32 port is of version 5.03, released in May 2009.
  It has a subtle bug that breaks libtool, and also a few Windows
  specific gotcha's (e.g., try &quot;file NUL&quot; or &quot;file -&quot;).  This port of
  the latest upstream release fixes those bugs.</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/file.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/file.png" type="image/png"/><category>Utility</category><homepage>https://sourceforge.net/projects/ezwinports/files/</homepage><entry-point binary-name="file" command="run"/></interface><interface uri="https://apps.0install.net/utils/findutils.xml"><name>FindUtils</name><summary xml:lang="en">FindUtils: find and then operate on files</summary><description xml:lang="en">`find' is a program which searches a directory tree to find a file or group of files. It walks the directory tree and reports all occurences of a file matching the user's specifications. 

`locate' scans one or more databases of filenames and displays any matches. 

`xargs' builds and executes command lines by gathering together arguments it reads on the standard input. Most often, these arguments are lists of file names generated by `find'
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>System</category><homepage>https://sourceforge.net/projects/ezwinports/files/</homepage><entry-point binary-name="find" command="run">
    <needs-terminal/>
    <name xml:lang="en">find</name>
    <summary xml:lang="en">find - search for files in a directory hierarchy</summary>
    <description xml:lang="en">This manual page documents the GNU version of find.  GNU
       find searches the directory tree rooted  at  each  given
       file  name  by evaluating the given expression from left
       to right, according to the rules of precedence (see sec-
       tion  OPERATORS),  until  the outcome is known (the left
       hand side is false for and operations, true for or),  at
       which point find moves on to the next file name.

       If  you  are using find in an environment where security
       is important (for example if you are using it  to  seach
       directories  that  are  writable  by  other  users), you
       should read the &quot;Security Considerations&quot; chapter of the
       findutils  documentation,  which is called Finding Files
       and comes with findutils.   That document also  includes
       a  lot more detail and discussion than this manual page,
       so you may find it a more useful source of  information.</description>
  </entry-point><entry-point binary-name="locate" command="locate">
    <needs-terminal/>
    <name xml:lang="en">locate</name>
    <summary xml:lang="en">locate - list files in databases that match a pattern</summary>
    <description xml:lang="en">For each given pattern,  locate  searches  one  or  more
       databases of file names and displays the file names that
       contain the pattern.  Patterns can  contain  shell-style
       metacharacters:  `*', `?', and `[]'.  The metacharacters
       do not treat `/' or `.'  specially.  Therefore,  a  pat-
       tern  `foo*bar'  can  match  a  file  name that contains
       `foo3/bar', and a pattern `*duck*' can match a file name
       that  contains  `lake/.ducky'.   Patterns  that  contain
       metacharacters should be quoted  to  protect  them  from
       expansion by the shell.</description>
  </entry-point><entry-point binary-name="xargs" command="xargs">
    <needs-terminal/>
    <name xml:lang="en">xargs</name>
    <summary xml:lang="en">xargs  -  build  and execute command lines</summary>
    <description xml:lang="en">xargs  reads items from the standard input, delimited by
       blanks (which can be protected  with  double  or  single
       quotes  or  a  backslash)  or newlines, and executes the
       command (default is /bin/echo) one or  more  times  with
       any  initial-arguments followed by items read from stan-
       dard input.  Blank  lines  on  the  standard  input  are
       ignored.</description>
  </entry-point><entry-point binary-name="updatedb" command="updatedb">
    <needs-terminal/>
    <name xml:lang="en">updatedb</name>
    <summary xml:lang="en">updatedb - update a file name database</summary>
    <description xml:lang="en">The file name databases contain lists of files that were
       in particular directory trees when  the  databases  were
       last  updated.  The file name of the default database is
       determined when locate and updatedb are  configured  and
       installed.   The  frequency with which the databases are
       updated and  the  directories  for  which  they  contain
       entries  depend  on  how often updatedb is run, and with
       which arguments.</description>
  </entry-point><entry-point binary-name="updatedbbat" command="updatedb">
    <needs-terminal/>
    <name xml:lang="en">updatedb bat</name>
    <summary xml:lang="en">This is a pale imitation of the original `updatedb.sh'</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/fixparts.xml"><name>FixParts</name><summary>fixes some common problems on MBR disks</summary><description>The FixParts utility fixes some common problems on Master Boot Record (MBR) disks.</description><homepage>http://www.rodsbooks.com/fixparts/</homepage><category>System</category><category>Utility</category><entry-point binary-name="fixparts" command="run"/></interface><interface uri="https://apps.0install.net/utils/wget.xml"><name>GNU Wget</name><summary xml:lang="en">A command-line utility for retrieving files using HTTP, HTTPS and FTP protocols.</summary><description xml:lang="en">GNU Wget is a free software package for retrieving files using HTTP, HTTPS, FTP and FTPS the most widely-used Internet protocols. It is a non-interactive commandline tool, so it may easily be called from scripts, cron jobs, terminals without X-Windows support, etc. 

GNU Wget has many features to make retrieving large files or mirroring entire web or FTP sites easy, including: 
◾Can resume aborted downloads, using REST and RANGE
◾Can use filename wild cards and recursively mirror directories
◾NLS-based message files for many different languages
◾ Optionally converts absolute links in downloaded documents to relative, so that downloaded documents may link to each other locally 
◾Runs on most UNIX-like operating systems as well as Microsoft Windows
◾Supports HTTP proxies
◾Supports HTTP cookies
◾Supports persistent HTTP connections
◾Unattended / background operation
◾Uses local file timestamps to determine whether documents need to be re-downloaded when mirroring
◾GNU Wget is distributed under the GNU General Public License.
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Network</category><homepage>https://eternallybored.org/misc/wget/</homepage><entry-point binary-name="wget" command="run">
    <needs-terminal/>
    <name xml:lang="en">Wget</name>
    <summary xml:lang="en">A command-line utility for retrieving files using HTTP, HTTPS and FTP protocols.</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/gdisk.xml"><name>GPT fdisk</name><summary>disk partitioning tool for modifying GPT disks</summary><description>GPT fdisk is a disk partitioning tool loosely modeled on Linux fdisk, but used for modifying GUID Partition Table (GPT) disks.</description><homepage>http://www.rodsbooks.com/gdisk/</homepage><category>System</category><category>Utility</category><entry-point binary-name="gdisk" command="run"/></interface><interface uri="https://apps.0install.net/utils/gawk.xml"><name>Gawk</name><summary xml:lang="en">Gawk: pattern scanning and processing language</summary><description xml:lang="en">Several kinds of tasks occur repeatedly when working with text files. You might want to extract certain lines and discard the rest. Or you may need to make changes wherever certain patterns appear, but leave the rest of the file alone. Writing single-use programs for these tasks in languages such as C, C++ or Pascal is time-consuming and inconvenient. Such jobs are often easier with awk. The awk utility interprets a special-purpose programming language that makes it easy to handle simple data-reformatting jobs. The GNU implementation of awk is called gawk; it is fully compatible with the System V Release 4 version of awk. gawk is also compatible with the POSIX specification of the awk language. This means that all properly written awk programs should work with gawk. Thus, we usually don’t distinguish between gawk and other awk implementations. Using awk allows you to: 
•Manage small, personal databases 
•Generate reports 
•Validate data 
•Produce indexes and perform other document preparation tasks 
•Experiment with algorithms that you can adapt later to other computer languages. 

In addition, gawk provides facilities that make it easy to: 
•Extract bits and pieces of data for processing 
•Sort data 
•Perform simple network communications. 

The Win32 port has some limitations, In particular the ‘|&amp;’ operator and TCP/IP networking are not supported. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>System</category><homepage>http://gnuwin32.sourceforge.net/packages/gawk.htm</homepage><entry-point binary-name="awk" command="awk">
    <needs-terminal/>
    <name xml:lang="en">awk</name>
    <summary xml:lang="en">Gawk: pattern scanning and processing language</summary>
  </entry-point><entry-point binary-name="gawk" command="run">
    <needs-terminal/>
    <name xml:lang="en">Gawk</name>
    <summary xml:lang="en">Gawk: pattern scanning and processing language</summary>
  </entry-point><entry-point binary-name="pgawk" command="pgawk">
    <needs-terminal/>
    <name xml:lang="en">Pgawk</name>
    <summary xml:lang="en">Pgawk: the profiling version of gawk.</summary>
    <description xml:lang="en">Pgawk: the profiling version of gawk. It is identical in every way to gawk , except that programs run more slowly, and it automatically in the file awkprof.out when done.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/gnupg.xml"><name>GnuPG</name><summary>GNU privacy guard - a free PGP replacement</summary><description>
GnuPG is GNU's tool for secure communication and data storage. It can be used to
encrypt data and to create digital signatures. It includes an advanced key
management facility and is compliant with the proposed OpenPGP Internet standard
as described in RFC2440.

GnuPG does not use any patented algorithms so it cannot be compatible with PGP2
because it uses IDEA (which is patented worldwide).</description><homepage>http://www.gnupg.org/</homepage><entry-point binary-name="gpg" command="run"/><entry-point command="gpgv">
    <needs-terminal/>
    <name>OpenPGP signature checking tool</name>
    <summary>stripped down version of gpg which is only able to check signatures</summary>
  </entry-point><entry-point command="gpgsplit">
    <needs-terminal/>
    <name>OpenPGP Split</name>
    <summary>splits an OpenPGP message into packets</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/grep.xml"><name>Grep</name><summary xml:lang="en">Grep: print lines matching a pattern</summary><description xml:lang="en">Grep searches one or more input files for lines containing a match to a specified pattern. By default, grep prints the matching lines.</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>https://sourceforge.net/projects/ezwinports/</homepage><entry-point binary-name="grep" command="run"/><entry-point binary-name="egrep" command="egrep">
    <needs-terminal/>
    <name xml:lang="en">Egrep</name>
    <summary xml:lang="en">Egrep: print lines matching a pattern</summary>
  </entry-point><entry-point binary-name="fgrep" command="fgrep">
    <needs-terminal/>
    <name xml:lang="en">Fgrep</name>
    <summary xml:lang="en">Fgrep: print lines matching a pattern</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/gzip.xml"><name>Gzip</name><summary xml:lang="en">Gzip: compress files</summary><description xml:lang="en">gzip (GNU zip) is a compression utility designed to be a replacement for compress. Its main advantages over compress are much better compression and freedom from patented algorithms. </description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/gzip.htm</homepage><entry-point binary-name="gzip" command="run">
    <needs-terminal/>
  </entry-point><entry-point binary-name="gunzip" command="gunzip">
    <needs-terminal/>
    <name xml:lang="en">gunzip</name>
    <summary xml:lang="en">expand files</summary>
  </entry-point><entry-point binary-name="gzexe" command="gzexe">
    <name xml:lang="en">gzexe</name>
    <summary xml:lang="en">Rename each FILE with a compressed version of itself, renaming FILE to FILE~.</summary>
    <description xml:lang="en">The  gzexe utility allows you to compress executables in
       place and have them automatically uncompress and execute
       when  you  run  them (at a penalty in performance).  For
       example if you execute ``gzexe  /usr/bin/gdb''  it  will
       create the following two files:
           -rwxr-xr-x  1 root root 1026675 Jun  7 13:53 /usr/bin/gdb
           -rwxr-xr-x  1 root root 2304524 May 30 13:02 /usr/bin/gdb~
       /usr/bin/gdb~  is  the original file and /usr/bin/gdb is
       the self-uncompressing executable file.  You can  remove
       /usr/bin/gdb~  once you are sure that /usr/bin/gdb works
       properly.

       This utility is most useful on systems with  very  small
       disks.</description>
  </entry-point><entry-point binary-name="uncompress" command="uncompress">
    <needs-terminal/>
    <name xml:lang="en">uncompress</name>
    <summary xml:lang="en">expand files</summary>
  </entry-point><entry-point binary-name="zcat" command="zcat">
    <needs-terminal/>
    <name xml:lang="en">zcat</name>
    <summary xml:lang="en">expand files</summary>
  </entry-point><entry-point binary-name="zcmp" command="zcmp">
    <needs-terminal/>
    <name xml:lang="en">zcmp</name>
    <summary xml:lang="en">Compare FILE1 to FILE2, using their uncompressed contents if they are</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... FILE1 [FILE2]
 If FILE2 is omitted, compare FILE1 to the uncompressed
contents of FILE1.gz.  Do comparisons like cmp does.

OPTIONs are the same as for cmp</description>
  </entry-point><entry-point binary-name="zdiff" command="zdiff">
    <needs-terminal/>
    <name xml:lang="en">zdiff</name>
    <summary xml:lang="en">Compare FILE1 to FILE2, using their uncompressed contents if they are</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... FILE1 [FILE2]
If FILE2 is omitted, compare FILE1 to the uncompressed
contents of FILE1.gz.  Do comparisons like diff does.

OPTIONs are the same as for diff</description>
  </entry-point><entry-point binary-name="zegrep" command="zegrep">
    <needs-terminal/>
    <name xml:lang="en">zegrep</name>
    <summary xml:lang="en">Look for instances of PATTERN in the input FILEs, using their</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... [-e] PATTERN [FILE]...

OPTIONs are the same as for 'grep'.
</description>
  </entry-point><entry-point binary-name="zfgrep" command="zfgrep">
    <needs-terminal/>
    <name xml:lang="en">zfgrep</name>
    <summary xml:lang="en">Look for instances of PATTERN in the input FILEs, using their</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... [-e] PATTERN [FILE]...

OPTIONs are the same as for 'grep'.
</description>
  </entry-point><entry-point binary-name="zgrep" command="zgrep">
    <needs-terminal/>
    <name xml:lang="en">zgrep</name>
    <summary xml:lang="en">Look for instances of PATTERN in the input FILEs, using their</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... [-e] PATTERN [FILE]...

OPTIONs are the same as for 'grep'.
</description>
  </entry-point><entry-point binary-name="zforce" command="zforce">
    <needs-terminal/>
    <name xml:lang="en">zforce</name>
    <summary xml:lang="en">Force a .gz extension on all compressed FILEs so that gzip will</summary>
    <description xml:lang="en">Usage: $0 [FILE]...
</description>
  </entry-point><entry-point binary-name="zless" command="zless">
    <needs-terminal/>
    <name xml:lang="en">zless</name>
    <summary xml:lang="en">Like 'less', but operate on the uncompressed contents of any compressed FILEs.</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... [FILE]...

Options are the same as for 'less'.
</description>
  </entry-point><entry-point binary-name="zmore" command="zmore">
    <needs-terminal/>
    <name xml:lang="en">zmore</name>
    <summary xml:lang="en">Like 'more', but operate on the uncompressed contents of any compressed FILEs.</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... [FILE]...

</description>
  </entry-point><entry-point binary-name="znew" command="znew">
    <needs-terminal/>
    <name xml:lang="en">znew</name>
    <summary xml:lang="en">Recompress files from .Z (compress) format to .gz (gzip) format.</summary>
    <description xml:lang="en">Usage: $0 [OPTION]... [FILE]...

Options:

  -f     Force recompression even if a .gz file already exists.
  -t     Test the new files before deleting originals.
  -v     Verbose; display name and statistics for each file compressed.
  -9     Use the slowest compression method (optimal compression).
  -P     Use pipes for the conversion to reduce disk space usage.
  -K     Keep a .Z file when it is smaller than the .gz file.
      --help     display this help and exit
      --version  output version information and exit
</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/help2man.xml"><name>Help2Man</name><summary xml:lang="en">Help2Man: generate man page from help text of program</summary><homepage>http://gnuwin32.sourceforge.net/packages/help2man.htm</homepage><entry-point binary-name="help2man" command="run">
    <needs-terminal/>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/imagemagick.xml"><name>ImageMagick</name><summary>create, edit, compose, or convert bitmap images</summary><description>ImageMagick can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, HEIC, TIFF, DPX, EXR, WebP, Postscript, PDF, and SVG. Use ImageMagick to resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/imagemagick.png" type="image/png"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/imagemagick.ico" type="image/vnd.microsoft.icon"/><category>Graphics</category><homepage>https://imagemagick.org/</homepage><entry-point binary-name="magick" command="run">
    <needs-terminal/>
    <name>magick</name>
    <summary>convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.</summary>
  </entry-point><entry-point binary-name="IMDisplay" command="run-gui">
    <name>IMDisplay Application</name>
  </entry-point><entry-point binary-name="magick-script" command="script">
    <needs-terminal/>
    <name>magick-script</name>
    <summary>use this scripting language interpreter to convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.</summary>
  </entry-point><entry-point binary-name="compare" command="compare">
    <needs-terminal/>
    <name>compare</name>
    <summary>mathematically and visually annotate the difference between an image and its reconstruction.</summary>
  </entry-point><entry-point binary-name="composite" command="composite">
    <needs-terminal/>
    <name>composite</name>
    <summary>overlap one image over another.</summary>
  </entry-point><entry-point binary-name="conjure" command="conjure">
    <needs-terminal/>
    <name>conjure</name>
    <summary>interpret and execute scripts written in the Magick Scripting Language (MSL).</summary>
  </entry-point><entry-point binary-name="convert" command="convert">
    <needs-terminal/>
    <name>convert</name>
    <summary>convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.</summary>
  </entry-point><entry-point binary-name="identify" command="identify">
    <needs-terminal/>
    <name>identify</name>
    <summary>describe the format and characteristics of one or more image files.</summary>
  </entry-point><entry-point binary-name="mogrify" command="mogrify">
    <needs-terminal/>
    <name>mogrify</name>
    <summary>resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more. Mogrify overwrites the original image file, whereas, convert writes to a different image file.</summary>
  </entry-point><entry-point binary-name="montage" command="montage">
    <needs-terminal/>
    <name>montage</name>
    <summary>create a composite image by combining several separate images. The images are tiled on the composite image optionally adorned with a border, frame, image name, and more.</summary>
  </entry-point><entry-point binary-name="stream" command="stream">
    <needs-terminal/>
    <name>stream</name>
    <summary>a lightweight tool to stream one or more pixel components of the image or portion of the image to your choice of storage formats. It writes the pixel components as they are read from the input image a row at a time making stream desirable when working with large images or when you require raw pixel components.</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/less.xml"><name>Less</name><summary xml:lang="en">file viewer</summary><description xml:lang="en">Less is a pager. A pager is a program that displays text files. Other pagers commonly in use are more and pg. Less is similar to more, but allows backward movement in the file as well as forward movement. Also, less does not have to read the entire input file before starting, so with large input files it starts up faster than text editors like vi. </description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>System</category><homepage>http://gnuwin32.sourceforge.net/packages/less.htm</homepage><entry-point binary-name="less" command="run">
    <needs-terminal/>
    <summary xml:lang="en">opposite of more</summary>
    <description xml:lang="en">Less is a program similar to more (1), but which  allows
       backward  movement  in the file as well as forward move-
       ment.  Also, less does not have to read the entire input
       file  before  starting,  so  with  large  input files it
       starts up faster than text editors like  vi  (1).   Less
       uses  termcap  (or  terminfo on some systems), so it can
       run on a variety of terminals.  There  is  even  limited
       support  for  hardcopy terminals.  (On a hardcopy termi-
       nal, lines which should be printed at  the  top  of  the
       screen are prefixed with a caret.)</description>
  </entry-point><entry-point binary-name="lessecho" command="lessecho">
    <needs-terminal/>
    <name xml:lang="en">Lessecho</name>
    <summary xml:lang="en">expand metacharacters</summary>
    <description xml:lang="en">lessecho is a program that simply echos its arguments on
       standard  output.  But any argument containing spaces is
       enclosed in quotes.</description>
  </entry-point><entry-point binary-name="lesskey" command="lesskey">
    <needs-terminal/>
    <name xml:lang="en">Lesskey</name>
    <summary xml:lang="en">specify key bindings for less</summary>
    <description xml:lang="en"> Lesskey  is  used to specify a set of key bindings to be
       used by less.  The input  file  is  a  text  file  which
       describes  the  key  bindings, If the input file is &quot;-&quot;,
       standard input is read.  If no input file is  specified,
       a  standard  filename  is  used as the name of the input
       file, which depends on the system being  used:  On  Unix
       systems,  $HOME/.lesskey  is  used;  on  MS-DOS systems,
       $HOME/_lesskey   is   used;   and   on   OS/2    systems
       $HOME/lesskey.ini is used, or $INIT/lesskey.ini if $HOME
       is undefined.  The output file is a binary file which is
       used  by  less.  If no output file is specified, and the
       environment  variable  LESSKEY  is  set,  the  value  of
       LESSKEY  is used as the name of the output file.  Other-
       wise, a standard filename is used as  the  name  of  the
       output  file, which depends on the system being used: On
       Unix and OS-9 systems, $HOME/.less is  used;  on  MS-DOS
       systems,  $HOME/_less  is  used;  and  on  OS/2 systems,
       $HOME/less.ini is used, or $INIT/less.ini  if  $HOME  is
       undefined.   If  the output file already exists, lesskey
       will overwrite it.</description>
  </entry-point><entry-point binary-name="lessfile" command="lessfile">
    <needs-terminal/>
    <name xml:lang="en">Lessfile</name>
    <summary xml:lang="en">input preprocessor for  less.</summary>
    <description xml:lang="en">lessfile  will  toss  the  contents/info on a file which
       less will then read.  After you are done, lessfile  will
       then  delete  the file.  This means that the process has
       to finish before you see it, but you get  nice  percent-
       ages (N%) up front.</description>
  </entry-point><entry-point binary-name="lesspipe" command="lesspipe">
    <needs-terminal/>
    <name xml:lang="en">Lesspipe</name>
    <summary xml:lang="en">input preprocessor for  less.</summary>
    <description xml:lang="en">lesspipe  will toss the contents/info on STDOUT and less
       will read them as they come across.  This means that you
       do  not  have  to wait for the decoding to finish before
       less shows you the file.  This also means that you  will
       get  a  'byte N' instead of an N% as your file position.
       You can seek to the end and back to get the N% but  that
       means you have to wait for the pipe to finish.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/libarchive.xml"><name>LibArchive</name><summary xml:lang="en">library for reading and writing streaming archives </summary><description xml:lang="en">Libarchive is a programming library that can create and read several different streaming archive formats, including most popular tar variants, several cpio formats, and both BSD and GNU ar variants. It can also write shar archives and read ISO9660 CDROM images and ZIP archives. The bsdtar program is an implementation of tar(1) that is built on top of libarchive. It started as a test harness, but has grown into a feature-competitive replacement for GNU tar. 

The libarchive library offers a number of features that make it both very flexible and very powerful. 
•Automatic format detection: libarchive can automatically determine both the compression and the archive format, regardless of the data source. (GNU tar and star only do full format detection when reading from a file, for instance. Gunnar Ritter's heirloom tar also does full automatic format detection.) 
•Reads popular formats: libarchive can read GNU tar, ustar, pax interchange format, cpio, zip, and ISO9660 formats. The internal architecture is easily extensible. The only requirement for read support is that all metadata for a file must precede the file data itself within the archive. 
•Writes popular formats: libarchive can write ustar, pax interchange format, cpio, and shar formats. The internal architecture is easily extensible. The only requirement for write support is that all metadata for a file must follow the preceding file's data within the archive. (Yes, there are formats that libarchive can write but not read and vice versa.) 
•Reads and writes POSIX formats: libarchive reads and writes POSIX-standard formats, including &quot;ustar,&quot; &quot;pax interchange format,&quot; and the POSIX &quot;cpio&quot; format. 
•Supports pax interchange format: Pax interchange format (which, despite the name, is really an extended tar format) eliminates almost all limitations of historic tar formats and provides a standard method for incorporating vendorspecific extensions. libarchive exploits this extension mechanism to support ACLs and file flags, for example. (Joerg Schilling's star archiver and recent versions of GNU tar also support pax interchange format.) 
•High-Level API: the libarchive API makes it fairly simple to build an archive from a list of filenames or to extract the entries from an archive. However, the API also provides extreme flexibility with regards to data sources. For example, there are generic hooks that allow you to write an archive to a socket or read data from an archive entry into a memory buffer. 
•Modular: The library design carefully minimizes link pollution. If you only need read support for a single format, for example, you will only get the required code. This minimizes the size of statically-linked executables. (In particular, zlib or libbz2 are only required if you specifically request gzip or bzip2 support.) 
•Extensible: The internal design uses generic interfaces for compression, archive format detection and decoding, and archive data I/O. It should be very easy to add new formats, new compression methods, or new ways of reading/writing archives. 
•Featureful: Libarchive handles ACLs, file flags, extended attributes, international characters, large files, long pathnames, and many other features. Details vary depending on the particular format, of course. 
•Fast: Libarchive minimizes data copying when handling archive files and contains carefully-tuned code for recreating objects on disk. 

The bsdtar archiving program is built on libarchive, so offers a variety of modern features. One unusual feature it offers is the ability to function as a format-conversion filter, reading entries from one archive and emitting an archive in a different format with the same contents. This feature was simple to implement because libarchive's robust automatic format detection makes it unnecessary to specify the format of the input archive. The bsdtar program has a number of advantages over previous tar implementations: 
•Library. Since the core functionality is in a library, it can be used by other tools, such as pkg_add. 
•Automatic format detection. Libarchive automatically detects the compression (none/gzip/bzip2) and format (old tar, ustar, gnutar, pax, cpio, iso9660, zip) when reading archives. It does this for any data source. 
•Pax Interchange Format Support. This is a POSIX/SUSv3 extension to the old &quot;ustar&quot; tar format that adds arbitrary extended attributes to each entry. Does everything that GNU tar format does, only better. 
•Handles file flags, ACLs, arbitrary pathnames, etc. Pax interchange format supports key/value attributes using an easily-extensible technique. Arbitrary pathnames, group names, user names, file sizes are part of the POSIX standard; libarchive extends this with support for file flags, ACLs, and arbitrary device numbers. 
•GNU tar support. Libarchive reads most GNU tar archives. If there is demand, this can be improved further. 
•BSD license. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/libarchive.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/libarchive.png" type="image/png"/><category>System</category><homepage>http://gnuwin32.sourceforge.net/packages/libarchive.htm</homepage><entry-point binary-name="bsdtar" command="run">
    <needs-terminal/>
    <name xml:lang="en">bsdtar</name>
    <summary xml:lang="en">manipulate tape archives</summary>
    <description xml:lang="en">tar creates and manipulates streaming archive files.  This
     implementation can extract from tar, pax, cpio, zip, jar,
     ar, and ISO 9660 cdrom images and can create tar, pax,
     cpio, ar, and shar archives.</description>
  </entry-point><entry-point binary-name="bsdcpio" command="bsdcpio">
    <needs-terminal/>
    <name xml:lang="en">bsdcpio</name>
    <summary xml:lang="en">copy files to and from archives</summary>
    <description xml:lang="en"> cpio copies files between archives and directories.  This
     implementation can extract from tar, pax, cpio, zip, jar,
     ar, and ISO 9660 cdrom images and can create tar, pax,
     cpio, ar, and shar archives.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/mktemp.xml"><name>MkTemp</name><summary xml:lang="en">Mktemp: return a temporary-file name</summary><description xml:lang="en">The mktemp utility takes a given file name template and overwrites a portion of it to create a unique file name. This allows shell scripts and other programs to safely create and use /tmp files. 

Install the mktemp package if you need to use shell scripts or other programs which will create and use unique /tmp files. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/mktemp.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/mktemp.png" type="image/png"/><homepage>http://gnuwin32.sourceforge.net/packages/mktemp.htm</homepage><entry-point binary-name="mktemp" command="run">
    <needs-terminal/>
    <summary xml:lang="en">make temporary filename (unique)</summary>
    <description xml:lang="en">The mktemp utility takes the given filename template and
     overwrites a portion of it to create a unique filename.
     The template may be any filename with some number of `Xs'
     appended to it, for example /tmp/tfile.XXXXXXXXXX.  If no
     template is specified a default of tmp.XXXXXXXXXX is used
     and the -t flag is implied (see below).</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/nmap.xml"><name>Nmap</name><summary>utility for network discovery and security auditing</summary><description>Nmap (Network Mapper) is a free and open source utility for network discovery and security auditing. Many systems and network administrators also find it useful for tasks such as network inventory, managing service upgrade schedules, and monitoring host or service uptime. Nmap uses raw IP packets in novel ways to determine what hosts are available on the network, what services (application name and version) those hosts are offering, what operating systems (and OS versions) they are running, what type of packet filters/firewalls are in use, and dozens of other characteristics. It was designed to rapidly scan large networks, but works fine against single hosts.</description><homepage>https://nmap.org/</homepage><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/nmap.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/nmap.png" type="image/png"/><category>Network</category><category>Utility</category><entry-point binary-name="nmap" command="run">
    <needs-terminal/>
  </entry-point><entry-point binary-name="ncat" command="ncat">
    <needs-terminal/>
    <name>Ncat</name>
    <summary>reads and writes data across networks from the command line</summary>
    <description>Ncat is a feature-packed networking utility which reads and writes data across networks from the command line. Ncat was written for the Nmap Project as a much-improved reimplementation of the venerable Netcat. It uses both TCP and UDP for communication and is designed to be a reliable back-end tool to instantly provide network connectivity to other applications and users. Ncat will not only work with IPv4 and IPv6 but provides the user with a virtually limitless number of potential uses.</description>
  </entry-point><entry-point binary-name="nping" command="nping">
    <needs-terminal/>
    <name>Nping</name>
    <summary>network packet generation tool / ping utiliy</summary>
    <description>Nping is an open source tool for network packet generation, response analysis and response time measurement. Nping can generate network packets for a wide range of protocols, allowing users full control over protocol headers. While Nping can be used as a simple ping utility to detect active hosts, it can also be used as a raw packet generator for network stack stress testing, ARP poisoning, Denial of Service attacks, route tracing, etc. Nping's novel echo mode lets users see how packets change in transit between the source and destination hosts. That's a great way to understand firewall rules, detect packet corruption, and more.</description>
  </entry-point><entry-point binary-name="ndiff" command="ndiff">
    <needs-terminal/>
    <name>Ndiff</name>
    <summary>a utility for comparing Nmap scan results</summary>
    <description>Ndiff is a tool to aid in the comparison of Nmap scans. Specifically, it takes two Nmap XML output files and prints the differences between them: hosts coming up and down, ports becoming open or closed, and things like that. Ndiff can produce output in human-readable text or machine-readable XML formats. Many people like to scan their networks regularly (daily, weekly, etc.) and then use ndiff to easily detect any changes.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/openssl.xml"><name>OpenSSL</name><summary>command-line toolkit for TLS and SSL protocols</summary><description>OpenSSL is a robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols.</description><homepage>https://www.openssl.org/</homepage><category>Utility</category><entry-point binary-name="openssl" command="run"/></interface><interface uri="https://apps.0install.net/utils/tree.xml"><name>Tree</name><summary xml:lang="en">Tree: list contents of directories in a tree-like format</summary><description xml:lang="en">Tree is a recursive directory listing program that  pro-
       duces  a  depth indented listing of files, which is col-
       orized ala dircolors if the LS_COLORS environment  vari-
       able  is  set  and output is to tty.  With no arguments,
       tree lists the files in  the  current  directory.   When
       directory  arguments are given, tree lists all the files
       and/or directories found in the given  directories  each
       in  turn.  Upon completion of listing all files/directo-
       ries found, tree  returns  the  total  number  of  files
       and/or directories listed.</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/tree.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/tree.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/tree.htm</homepage><entry-point binary-name="tree" command="run">
    <needs-terminal/>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/unrar.xml"><name>UnRar</name><summary xml:lang="en">unpack RAR archives</summary><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/unrar.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/unrar.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/unrar.htm</homepage><entry-point binary-name="unrar" command="run">
    <needs-terminal/>
    <name xml:lang="en">unrar</name>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/unzip.xml"><name>UnZip</name><summary xml:lang="en">UnZip SPECS UnZip: list, test and extract compressed files in a ZIP archive</summary><description xml:lang="en">UnZip is an extraction utility for archives compressed in .zip format (also called &quot;zipfiles&quot;). Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own Zip program, our primary objectives have been portability and non-MSDOS functionality. 

UnZip will list, test, or extract files from a .zip archive, commonly found on MS-DOS systems. The default behavior (with no options) is to extract into the current directory (and subdirectories below it) all files from the specified zipfile. A companion program, Zip, creates .zip archives; both programs are compatible with archives created by PKZIP and PKUNZIP for MS-DOS, but in many cases the program options or default behaviors differ. (For example, UnZip recreates the stored directory structure by default; PKUNZIP unpacks all files in the current directory by default.)
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/unzip.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/unzip.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/unzip.htm</homepage><entry-point binary-name="unzip" command="run">
    <needs-terminal/>
    <name xml:lang="en">unzip</name>
    <summary xml:lang="en">unzip: list, test and extract compressed files in a ZIP</summary>
    <description xml:lang="en">unzip  will  list, test, or extract files from a ZIP ar-
       chive, commonly found on MS-DOS  systems.   The  default
       behavior  (with  no options) is to extract into the cur-
       rent directory (and subdirectories below it)  all  files
       from  the  specified  ZIP archive.  A companion program,
       zip(1L), creates ZIP archives; both programs are compat-
       ible with archives created by PKWARE's PKZIP and PKUNZIP
       for MS-DOS, but in many cases  the  program  options  or
       default behaviors differ.</description>
  </entry-point><entry-point binary-name="funzip" command="funzip">
    <needs-terminal/>
    <name xml:lang="en">Funzip</name>
    <summary xml:lang="en">Funzip: filter for extracting from a ZIP archive in a pipe</summary>
    <description xml:lang="en">funzip  without  a  file argument acts as a filter; that
       is, it assumes that a ZIP archive (or a gzip'd(1)  file)
       is  being piped into standard input, and it extracts the
       first member from the archive  to  stdout.   When  stdin
       comes from a tty device, funzip assumes that this cannot
       be a stream of (binary)  compressed  data  and  shows  a
       short  help text, instead.  If there is a file argument,
       then input is read from the specified  file  instead  of
       from stdin.</description>
  </entry-point><entry-point binary-name="SFXWiz32" command="SFXWiz32">
    <name xml:lang="en">SFXWiz32</name>
  </entry-point><entry-point binary-name="unzipsfx" command="unzipsfx">
    <needs-terminal/>
    <name xml:lang="en">UnzipSfx</name>
    <summary xml:lang="en">UnzipSfx: self-extracting stub for prepending to ZIP archives</summary>
    <description xml:lang="en">unzipsfx  is a modified version of unzip(1L) designed to
       be prepended to existing ZIP archives in order  to  form
       self-extracting  archives.   Instead of taking its first
       non-flag argument to be the zipfile(s) to be  extracted,
       unzipsfx  seeks  itself  under  the name by which it was
       invoked and  tests  or  extracts  the  contents  of  the
       appended archive.  Because the executable stub adds bulk
       to the archive (the whole purpose of which is to  be  as
       small as possible), a number of the less-vital capabili-
       ties in regular unzip have been  removed.   Among  these
       are the usage (or help) screen, the listing and diagnos-
       tic functions (-l and -v),  the  ability  to  decompress
       older  compression  formats  (the ``reduce,'' ``shrink''
       and ``implode'' methods).  The ability to extract  to  a
       directory  other than the current one can be selected as
       a compile-time option, which is now enabled  by  default
       since  UnZipSFX  version  5.5.   Similary, decryption is
       supported as a compile-time option but should be avoided
       unless  the  attached  archive contains encrypted files.
       Starting with release 5.5, another  compile-time  option
       adds  a simple ``run command after extraction'' feature.
       This  feature  is  currently   incompatible   with   the
       ``extract  to  different directory'' feature and remains
       disabled by default.</description>
  </entry-point><entry-point binary-name="zipinfo" command="zipinfo">
    <needs-terminal/>
    <name xml:lang="en">ZipInfo</name>
    <summary xml:lang="en">ZipInfo: list detailed information about a ZIP archive</summary>
    <description xml:lang="en">zipinfo lists technical information about files in a ZIP
       archive, most commonly found on  MS-DOS  systems.   Such
       information includes file access permissions, encryption
       status, type of compression, version and operating  sys-
       tem or file system of compressing program, and the like.
       The default behavior (with no options) is to  list  sin-
       gle-line  entries  for  each  file  in the archive, with
       header and trailer lines providing  summary  information
       for  the  entire archive.  The format is a cross between
       Unix ``ls -l'' and ``unzip -v''  output.   See  DETAILED
       DESCRIPTION  below.   Note that zipinfo is the same pro-
       gram as unzip (under Unix, a link to it); on  some  sys-
       tems,  however,  zipinfo  support  may have been omitted
       when unzip was compiled.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/units.xml"><name>Units</name><summary xml:lang="en">Units: unit conversion and calculation</summary><description xml:lang="en">Units is a program for units conversion and units calculation. The program converts quantities expressed in various scales to their equivalents in other scales. Units can only handle multiplicative scale changes. For example, it cannot convert Celsius to Fahrenheit but it can convert temperature differences between those temperature scales. 

The units are defined in an external data file. Units comes with an extensive, well annotated data file that defines over 2000 units. Alternatively you can provide your own data file to suit your needs. 

The Units database includes scientific values, historical units, and useful day to day values such as the densities of cooking ingredients, needed to convert between European and American recipes. 
</description><category>Science</category><homepage>http://gnuwin32.sourceforge.net/packages/units.htm</homepage><entry-point binary-name="units" command="run">
    <needs-terminal/>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/which.xml"><name>Which</name><summary xml:lang="en">Which: show the full path of (shell) commands</summary><description xml:lang="en">Which takes one or more arguments. For each of its arguments it prints to stdout the full path of the executables that would have been executed when this argument had been entered at the shell prompt. It does this by searching for an executable or script in the directories listed in the environment variable PATH using the same algorithm as bash. 

The GnuWin32 port of Which searches for a matching file in the following sequence of directories: 
•The current directory. 
•The directories that are listed in the PATH environment variable. 

If the filename given on the command line cannot be found in any of the above directories, the search is repeated with the extensions given in the environment variable PATHEXT until a match occurs. If PATHEXT is empty or does not exist, a value of &quot;.com;.exe;.bat;.cmd&quot; is assumed. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/which.htm</homepage><entry-point binary-name="which" command="run">
    <needs-terminal/>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/xz.xml"><name>XZ Utils</name><summary>xz data compression tool for .xz and .lzma files</summary><description>XZ Utils is free general-purpose data compression software with high compression ratio. XZ Utils are the successor to LZMA Utils.</description><homepage>http://tukaani.org/xz/</homepage><category>Utility</category><entry-point binary-name="xz" command="run">
    <name>compress .xz file</name>
    <needs-terminal/>
  </entry-point><entry-point command="unxz">
    <name>decompress .xz file</name>
    <needs-terminal/>
  </entry-point><entry-point command="xzcat">
    <name>decompress .xz file to stdout</name>
    <needs-terminal/>
  </entry-point><entry-point command="lzma">
    <name>compress .lzma file</name>
    <needs-terminal/>
  </entry-point><entry-point command="unlzma">
    <name>decompress .lzma file</name>
    <needs-terminal/>
  </entry-point><entry-point command="lzcat">
    <name>decompress .lzma file to stdout</name>
    <needs-terminal/>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/zip.xml"><name>Zip</name><summary xml:lang="en">Zip: package and compress zip-archive files</summary><description xml:lang="en">Zip is a compression and file packaging/archive utility. Although \highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectives have been portability and other-than-MSDOS functionality. Features not found in the PKWARE version include: 
•creating zipfiles in a pipe or on a device 
•VMS and OS/2 extended file attributes 
•conversion between Unix, MS-DOS and Macintosh text file formats 
•the ability to run on most of your favorite operating systems. 

Zip is useful for packaging a set of files for distribution, for archiving files, and for saving disk space by temporarily compressing unused files or directories. Zip puts one or more compressed files into a single ZIP archive, along with information about the files (name, path, date, time of last modification, protection, and check information to verify file integrity). An entire directory structure can be packed into a ZIP archive with a single command. 

Zip has one compression method (deflation) and can also store files without compression. Zip automatically chooses the better of the two for each file. Compression ratios of 2:1 to 3:1 are common for text files. 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/unzip.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/unzip.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/zip.htm</homepage><entry-point binary-name="zip" command="run">
    <needs-terminal/>
    <name xml:lang="en">zip</name>
    <summary xml:lang="en">zip - package and compress (archive) files</summary>
    <description xml:lang="en">zip  is  a  compression  and  file packaging utility for
       Unix, VMS, MSDOS, OS/2, Windows 9x/NT/XP, Minix,  Atari,
       Macintosh, Amiga, and Acorn RISC OS.  It is analogous to
       a combination of  the  Unix  commands  tar(1)  and  com-
       press(1)  and  is compatible with PKZIP (Phil Katz's ZIP
       for MSDOS systems).</description>
  </entry-point><entry-point binary-name="zipcloak" command="zipcloak">
    <needs-terminal/>
    <name xml:lang="en">Zipcloak</name>
    <summary xml:lang="en">Zipcloak: encrypt entries in a zipfile</summary>
    <description xml:lang="en">zipcloak  encrypts  all  unencrypted entries in the zipfile.</description>
  </entry-point><entry-point binary-name="zipnote" command="zipnote">
    <needs-terminal/>
    <name xml:lang="en">Zipnote</name>
    <summary xml:lang="en">Zipnote: write the comments in zipfile to stdout, edit comments and rename files in zipfile</summary>
    <description xml:lang="en">zipnote  writes  the  comments  in  a zipfile to stdout.
       This is the default mode.  A second mode allows updating
       the comments in a zipfile as well as allows changing the
       names of the files in  the  zipfile.   These  modes  are
       described below.</description>
  </entry-point><entry-point binary-name="zipsplit" command="zipsplit">
    <needs-terminal/>
    <name xml:lang="en">Zipsplit</name>
    <summary xml:lang="en">Zipsplit: split a zipfile into smaller zipfiles</summary>
    <description xml:lang="en">zipsplit reads a zipfile and splits it into smaller zipfiles.</description>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/aspcud.xml"><name>aspcud</name><summary>a solver for CUDF instances based on ASP tools</summary><description>
aspcud is a solver for CUDF (Common Upgradeability Description Format) instances
based on ASP tools developed within the potassco project. It utilizes the
preprocessor cudf2lp that rewrites CUDF specifications into ASP facts. These
facts together with an ASP program are then passed to grounder gringo and are
finally solved by solver clasp.</description><homepage>http://www.cs.uni-potsdam.de/wv/aspcud/</homepage><category>Utility</category></interface><interface uri="https://apps.0install.net/utils/bash.xml"><name>bash</name><summary>the GNU Bourne Again shell</summary><description>
Bash is the shell, or command language interpreter, for the GNU operating
system. The name is an acronym for the ‘Bourne-Again SHell’, a pun on
Stephen Bourne, the author of the direct ancestor of the current Unix shell sh,
which appeared in the Seventh Edition Bell Labs Research version of Unix.

Bash is largely compatible with sh and incorporates useful features from the
Korn shell ksh and the C shell csh. It is intended to be a conformant
implementation of the IEEE POSIX Shell and Tools portion of the IEEE POSIX
specification (IEEE Standard 1003.1). It offers functional improvements over sh
for both interactive and programming use.

Since bash is included on most Unix systems, this feed is mainly useful for
Windows systems, where it provides a binary of win-bash (http://win-
bash.sourceforge.net/).</description><homepage>http://www.gnu.org/software/bash/</homepage><category>Utility</category></interface><interface uri="https://apps.0install.net/utils/curl.xml"><name>cURL</name><summary>command line tool for transferring data</summary><description>
    cURL is a command line tool for transferring data with URL syntax,
    supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS,
    LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet
    and TFTP. cURL supports SSL certificates, HTTP POST, HTTP PUT, FTP
    uploading, HTTP form based upload, proxies, cookies, user+password
    authentication (Basic, Digest, NTLM, Negotiate, kerberos...), file
    transfer resume, proxy tunneling and a busload of other useful
    tricks.
  </description><category>Network</category><category>Utility</category><entry-point binary-name="curl" command="run"/></interface><interface uri="https://apps.0install.net/utils/chocolatey.xml"><name>chocolatey</name><summary>package manager for Windows</summary><description>Chocolatey is a package manager for Windows (like apt-get but for Windows). It was designed to be a decentralized framework for quickly installing applications and tools that you need. It is built on the NuGet infrastructure currently using PowerShell as its focus for delivering packages from the distros to your door, err computer.</description><icon href="https://chocolatey.org/content/packageimages/chocolatey.0.10.15.png" type="image/png"/><homepage>https://chocolatey.org/</homepage><entry-point binary-name="choco" command="run"/><entry-point binary-name="RefreshEnv" command="refresh-env">
    <needs-terminal/>
    <name>Refresh Environment</name>
    <summary>read environment variables from registry and set session variables to these values</summary>
  </entry-point><entry-point binary-name="chocolatey" command="chocolatey">
    <needs-terminal/>
    <name>chocolatey</name>
    <summary>alias for 'choco'</summary>
  </entry-point><entry-point binary-name="cinst" command="install">
    <needs-terminal/>
    <summary>installs packages from various sources</summary>
  </entry-point><entry-point binary-name="cuninst" command="uninstall">
    <needs-terminal/>
    <summary>uninstalls a package</summary>
  </entry-point><entry-point binary-name="cup" command="upgrade">
    <needs-terminal/>
    <summary>upgrades packages from various sources</summary>
  </entry-point><entry-point binary-name="clist" command="list">
    <needs-terminal/>
    <summary>lists remote or local packages</summary>
  </entry-point><entry-point binary-name="cpack" command="pack">
    <needs-terminal/>
    <summary>packages up a nuspec to a compiled nupkg</summary>
  </entry-point><entry-point binary-name="cpush" command="push">
    <needs-terminal/>
    <summary>pushes a compiled nupkg</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/grpcurl.xml"><name>gRPCurl</name><summary>command-line tool that lets you interact with gRPC servers</summary><description>grpcurl is a command-line tool that lets you interact with gRPC servers. It's basically curl for gRPC servers.</description><homepage>https://github.com/fullstorydev/grpcurl</homepage><entry-point binary-name="grpcurl" command="run"/></interface><interface uri="https://apps.0install.net/utils/gnuplot.xml"><name>gnuplot</name><summary>famous scientific plotting package</summary><description>gnuplot is a portable command-line driven graphing utility.</description><homepage>http://gnuplot.sourceforge.net/</homepage><category>Graphics</category><category>Utility</category><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnuplot.png" type="image/png"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnuplot.ico" type="image/vnd.microsoft.icon"/><entry-point binary-name="gnuplot" command="run">
    <name>Gnuplot command-line interface</name>
    <name xml:lang="de">Gnuplot Befehlszeilenoberfläche</name>
  </entry-point><entry-point binary-name="wgnuplot" command="run-gui">
    <name>Gnuplot graphical interface</name>
    <name xml:lang="de">Gnuplot grafische Oberfläche</name>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/graphviz.xml"><name>graphviz</name><summary>Open Source Graph Visualization Software</summary><description>Open Source Graph Visualization Software</description><homepage>http://www.graphviz.org/</homepage><entry-point binary-name="dot" command="run">
    <name>dot</name>
    <needs-terminal/>
    <summary>draws directed graphs</summary>
  </entry-point><entry-point binary-name="neato" command="neato">
    <needs-terminal/>
    <summary>draws undirected graphs using 'spring' models</summary>
  </entry-point><entry-point binary-name="twopi" command="twopi">
    <needs-terminal/>
    <summary>draws graphs using a radial layout</summary>
  </entry-point><entry-point binary-name="circo" command="circo">
    <needs-terminal/>
    <summary>draws graphs using a circular layout</summary>
  </entry-point><entry-point binary-name="fdp" command="fdp">
    <needs-terminal/>
    <summary>draws undirected graphs using a 'spring' model</summary>
  </entry-point><entry-point binary-name="sfdp" command="sfdp">
    <needs-terminal/>
    <summary>draws undirected graphs using a 'spring' model and a multi-scale approach</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/jq.xml"><name>jq</name><summary>command-line JSON processor</summary><description>jq is a lightweight and flexible command-line JSON processor.</description><homepage>https://stedolan.github.io/jq/</homepage><category>Utility</category><entry-point binary-name="jq" command="run"/></interface><interface uri="https://apps.0install.net/utils/sed.xml"><name>sed</name><summary xml:lang="en">Sed: stream editor</summary><description xml:lang="en">Sed (streams editor) isn't really a true text editor or text processor. Instead, it is used to filter text, i.e., it takes text input and performs some operation (or set of operations) on it and outputs the modified text. Sed is typically used for extracting part of a file using pattern matching or substituting multiple occurances of a string within a file. 

Version 1.4 is the fast, small sed originally distributed in the GNU toolkit and still distributed with Minix -- but it's still better for some uses (in particular, faster and less memory-intensive). 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/gnu.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/sed.htm</homepage><entry-point binary-name="sed" command="run"/></interface><interface uri="https://apps.0install.net/utils/util-linux.xml"><name>util-linux</name><summary xml:lang="en">Util-Linux: various system utilities</summary><description xml:lang="en">Util-Linux contains miscellaneous utilities: 
•col: filter reverse line feeds from input 
•colcrt: filter nroff output for CRT previewing 
•colrm: remove columns from a file 
•ddate: converts Gregorian dates to Discordian dates 
•getopt: parse command options (enhanced) 
•hexdump: ascii, decimal, hexadecimal, octal dump 
•line: read one line 
•rename: rename files 
•rev: reverse lines of a file or files 
•tailf: follow the growth of a log file 
•whereis: locate the binary, source, and manual page files for a command 
</description><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/util-linux.ico" type="image/vnd.microsoft.icon"/><icon href="https://raw.githubusercontent.com/0install/apps/master/utils/util-linux.png" type="image/png"/><category>Utility</category><homepage>http://gnuwin32.sourceforge.net/packages/util-linux-ng.htm</homepage><entry-point binary-name="whereis" command="whereis">
    <needs-terminal/>
    <name xml:lang="en">whereis</name>
    <summary xml:lang="en">whereis: locate the binary, source, and manual page files for a command</summary>
  </entry-point><entry-point binary-name="col" command="col">
    <needs-terminal/>
    <name xml:lang="en">Col</name>
    <summary xml:lang="en">Col: filter reverse line feeds from input </summary>
  </entry-point><entry-point binary-name="colcrt" command="colcrt">
    <needs-terminal/>
    <name xml:lang="en">Colcrt</name>
    <summary xml:lang="en">Colcrt: filter nroff output for CRT previewing </summary>
  </entry-point><entry-point binary-name="colrm" command="colrm">
    <needs-terminal/>
    <name xml:lang="en">Colrm</name>
    <summary xml:lang="en">Colrm: remove columns from a file </summary>
  </entry-point><entry-point binary-name="ddate" command="ddate">
    <needs-terminal/>
    <name xml:lang="en">Ddate</name>
    <summary xml:lang="en">Ddate: converts Gregorian dates to Discordian dates </summary>
  </entry-point><entry-point binary-name="getopt" command="getopt">
    <needs-terminal/>
    <name xml:lang="en">Getopt</name>
    <summary xml:lang="en">Getopt: parse command options (enhanced) </summary>
  </entry-point><entry-point binary-name="hexdump" command="hexdump">
    <needs-terminal/>
    <name xml:lang="en">Hexdump</name>
    <summary xml:lang="en">Hexdump: ascii, decimal, hexadecimal, octal dump </summary>
  </entry-point><entry-point binary-name="line" command="line">
    <needs-terminal/>
    <name xml:lang="en">Line</name>
    <summary xml:lang="en">Line: read one line</summary>
  </entry-point><entry-point binary-name="rename" command="rename">
    <needs-terminal/>
    <name xml:lang="en">Rename</name>
    <summary xml:lang="en">Rename: rename files </summary>
  </entry-point><entry-point binary-name="rev" command="rev">
    <needs-terminal/>
    <name xml:lang="en">Rev</name>
    <summary xml:lang="en">Rev: reverse lines of a file or files </summary>
  </entry-point><entry-point binary-name="tailf" command="tailf">
    <needs-terminal/>
    <name xml:lang="en">Tailf</name>
    <summary xml:lang="en">Tailf: follow the growth of a log file</summary>
  </entry-point></interface><interface uri="https://apps.0install.net/utils/youtube-dl.xml"><name>youtube-dl</name><summary xml:lang="en">command-line program to download videos from YouTube</summary><summary xml:lang="de">Befehlszeilenprogramm zum Runterladen von Videos von YouTube</summary><description xml:lang="en">youtube-dl is a command-line program to download videos from YouTube.com and a few more sites.</description><description xml:lang="de">youtube-dl ist ein Befehlszeilenprogramm zum Runterladen von Videos von YouTube und ein paar weiteren Seiten.</description><category>Utility</category><homepage>http://rg3.github.io/youtube-dl/</homepage><entry-point binary-name="youtube-dl" command="run"/></interface></c:catalog>
<!-- Base64 Signature
iQEzBAABCgAdFiEEiMih83WShpHXNlwCWao5J8JOTh4FAl7KXoQACgkQWao5J8JOTh45uAf9HgjT
RnU98LCnoYrfixE/Jfn+DReXRYRbj4el7FAJRuLT6chtFj6HDt3bWglJ5MqnzAdunBzJCuRDbnus
0iRSEqVfvyPg0KToRyuS+nloaCUXvMjphGbYp6VnMOWy8Ee1bEF/e21ocBsrmAIQxFRtEbkNxcZl
5lV9Q/3RxJbu3nILsmJMqy/yg/m5a+72YslDPk7nuGoWozEsuXmVpcuRhs/ybclnD43jNc6wYAaq
dwGZJgwrISgq4bXA9Tvbofz0ZDS9VL6voYdytWkpdgHz/LJz2BLh2WY6QTu7t68caO+zloPlOw7L
ZTYki08HcFAaiAH/NqtUQTAX1hdaOXge7g==

-->
